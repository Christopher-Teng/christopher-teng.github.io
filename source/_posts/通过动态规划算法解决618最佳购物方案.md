---
title: 通过动态规划算法解决618最佳购物方案
date: 2021-04-05 19:45:04
tags:
  - Python
categories:
  - 算法
---

最近刚装修完新房，新家种种东西方方面面都亟待采买，正好还有两个多月便是 618，打算趁着促销活动，购置一批生活家电。

看着各大网购平台上琳琅满目的商品，各种宣传导购、直播带货，感觉每样东西不是吊炸天便是亮瞎眼，恨不能来者不拒，买买买...，奈何囊中羞涩，为了不至于“一波买买买，稀饭喝到腿发软”，只好提前计划，理性消费。

首先规划好消费总额，暂定为只使用信用卡额度的 70%。

```python
TOTAL_ASSETS = 10000  # 总资产
RATE = 0.7  # 使用百分比
AVAILABLE_ASSET = TOTAL_ASSETS*RATE  # 可用资产
```

接下来需要列出商品清单，这里要考虑好以什么作为参考来判断最后得出的购买清单是最优的，以及以什么作为参数来选择商品。

首先，既然限制了消费总额，因此使用商品的价格来作为选择与否的依据；其次，对于每样商品，会有一个需求度的期望值，也就是说该商品是否急需使用。举个例子，如果将需求度按 1 到 10 来划分，冰箱的需求度是 10(家里面总是会有东西需要冷藏)，而破壁机的需求度是 5(平时做点鲜果汁、热豆浆什么的，营养又健康，但是没有的话对生活影响不会太大)。那么，最后的购买清单便以尽可能达到最大需求度为最优解。

下面列出商品清单：

```python
COMMODITY_LIST = {
    '苏泊尔电饭煲': (319, 10),
    '海尔净水器': (1188, 8),
    '海尔智能门锁': (1399, 9),
    '九阳破壁机': (449, 5),
    '海尔智能音箱': (199, 3),
    '海尔冰箱': (3199, 10),
    '海尔滚筒洗衣机': (2699, 10),
    '格力空气循环扇': (399, 6),
    '苏泊尔电压力锅': (259, 7),
    '碧然德滤水壶': (219, 5)
}
```

动态规划的原理是从小问题着手，然后逐步解决大问题。在这里，可以对总金额进行划分，比如先假设只能使用 100 块，然后找出当前的最佳购买方式，接着再假设只能使用 200 块，此时已经知道了使用 100 块时的最佳购买方式，只需要在此基础上看看使用 200 块能多买到什么东西，然后和上一次的计算结果进行比较，就可以轻松得出可以使用 200 块时的最佳购买方式，以此类推。

<!-- more -->

使用动态规划通常都会伴随着使用网格。首先建立一张表格，其中每一行都对应一种商品，每一列对应当前假设可以使用的金额，单元格中的数值就是获得的需求值。每个单元格的初始值为 0，即当前还没有选择购买任何商品。这里为了方便演示，只列出前 10 列，即最大可用金额为 1000，如下图：

{% asset_image new.png %}

```python
def generate_shopping_list(money, commodities):
    """
    指定可用金额作为约束条件，从提供的可选商品中选择出最佳选择方式，获取最多的需求值
    """
    current_asset = [
        i+100 for i in range(0, int(money), 100)]  # 将可用资产以100为最小单位进行划分
    commodity_names = list(commodities.keys())  # 所有可选商品
    selected_goods = [[set() for _ in current_asset]
                      for _ in commodity_names]  # 每个单元格中选中的商品，初始为空
    table = [[0 for _ in current_asset]
             for _ in commodity_names]  # 用于动态规划计算的网格
```

现在，可以开始进行动态规划计算：

1. 首先，查看当前行对应商品的价格，将其与每一列的可用金额进行对比，这里可能出现两种情况：

   1. 当前可用金额小于商品价格：

      这种情况下，不能选择该商品，那么单元格中的值就应该是上一次计算所得。对于第一行，也就是第一次计算来说，保持单元格中的值不动。

   2. 当前可用金额大于等于商品价格：

      这种情况下，可以选择购买该商品，让我们来计算可以获得多少需求值：

      1. 第一步，查看该商品的需求值**“当前商品需求值”**

      2. 第二步，计算余额，即如果选择购买该商品，还剩多少钱可用，**“当前余额”** = **“当前可用金额”** - **“当前商品价格”**

      3. 第三步，计算余额可获得的需求值，**“余额可得需求值”** = **“上一行”**和**“最接近余额的可用金额所在列”**对应的单元格中的需求值。

         举例来说，假设现在计算第四行“九阳破壁机（449，5）”和最后一列“￥ 1000.00”，那么购买破壁机后，余额等于 1000 - 449 = 551，那么余额可得需求值应该查找第三行第 5 列(￥ 500.00)单元格中的值。假如我们现在计算的是第四行第五列，那么余额等于 500 - 449 = 51，而最小可用金额是 100，说明余额已经不足最小可计算的可用金额，那么余额可得需求值就为 0。类似的，当第一次计算时，选择当前商品后，无论剩多少钱，都没有东西可选，即余额可得需求值也为 0。

      4. 第四步，计算选择该商品后可以获得的需求值，**“选择当前商品可得需求值”** = **“当前商品需求值”** + **“余额可得需求值”**

      5. 第五步，查看当前可用金额下上一次计算的结果，**“上一次计算结果”** = **"本列上一行"**对应单元格中的需求值

         当计算第一行时，即第一次计算，上一次计算结果可以认为是 0，即单元格中的初始需求值。

      6. 最后一步，比较**“选择当前商品可得需求值”**和**“上一次计算结果”**，如果**“上一次计算结果需求值更大”**，则将当前单元格更新为**“上一次计算结果”**，否则，将当前单元格更新为**“选择当前商品可得需求值”**。这里注意要同步更新选择的商品。

      {% asset_image step1.png %}

      ```python
      def update_cells(row, column):
         """
         更新单元格的方法，传入当前单元格的行、列数
         """
         current_commodity = commodity_names[row]  # 当前商品名
         (price, grade) = commodities[current_commodity]  # 当前商品价格和需求值
         asset = current_asset[column]  # 当前可用金额
         if row == 0:  # 第一次计算的时候
               if asset >= price:  # 当前可用金额大于等于当前商品价格
                  table[row][column] = grade  # 更新当前单元格数值
                  selected_goods[row][column].add(
                     current_commodity)  # 更新当前单元格选择商品
         else:
               if asset >= price:  # 当前可用金额大于等于当前商品价格
                  remaining_asset = asset-price  # 剩余金额
                  # 最大的剩余可用金额，这里比如手中还剩371，则对应最大的剩余可用金额是300
                  max_remaining_available_asset = (remaining_asset//100)*100
                  remaining_asset_index = -1 if max_remaining_available_asset == 0 else current_asset.index(
                     max_remaining_available_asset)
                  # 剩余金额可以获得的需求值
                  remainder_grade = table[commodity_index -
                                          1][remaining_asset_index] if remaining_asset_index > -1 else 0
                  current_total_grade = grade+remainder_grade  # 当前商品需求值和剩余金额可获得需求值之和
                  # 本列上一行单元格的值，即当前可用金额下，前一次计算所得的最大需求值
                  prev_grade = table[row-1][column]
                  if current_total_grade >= prev_grade:  # 更新当前单元格
                     table[row][column] = current_total_grade
                     if remaining_asset_index > -1:  # 选择当前商品后，并且剩余金额大于等于100
                           prev_selected_goods = selected_goods[row -
                                                               1][remaining_asset_index].copy()
                           prev_selected_goods.add(current_commodity)
                           # 更新当前单元格选择的商品
                           selected_goods[row][column] = prev_selected_goods
                     else:  # 选择当前商品后，剩余金额不足100
                           selected_goods[row][column] = {
                              current_commodity}
                  else:
                     table[row][column] = table[row-1][column]
                     selected_goods[row][column] = selected_goods[row -
                                                                  1][column].copy()
               else:
                  # 当前可用金额小于当前商品价格时
                  # 更新当前单元格需求值为上一次计算结果
                  table[row][column] = table[row-1][column]
                  # 更新当前单元格选择商品为上一次计算结果
                  selected_goods[row][column] = selected_goods[row -
                                                               1][column].copy()
      ```

2. 查看下一行，并且依照上面的方法更新单元格。

   {% asset_image step2.png %}

   ```python
   for commodity_index in range(len(commodity_names)):  # 遍历每一行，即每种可选商品
      for asset_index in range(len(current_asset)):  # 遍历每一列，即每一档可用金额
         update_cells(commodity_index, asset_index)  # 更新单元格
   ```

最终，当我们更新完最后一个单元格时，整个动态规划算法结束，最后一个单元格的需求值就是我们求得的最优解，对应选择的商品就是最佳购物方式。

{% asset_image last.png %}

```python
return {'选择的商品': selected_goods[-1][-1], '获得的需求值': table[-1][-1]}
```

最终计算出的结果如下：

```python
{'选择的商品': {'海尔滚筒洗衣机', '海尔智能门锁', '海尔智能音箱', '海尔净水器', '格力空气循环扇', '碧然德滤水壶', '苏泊尔电压力锅', '苏泊尔电饭煲'},
'获得的需求值': 58}
```

如果现在我又有几件商品想要购买，那么可以继续加入表格中，从新添加的行开始，照上面的方法继续计算，最终仍然可以得到最优解，而且即使打乱各行的顺序，即可选商品加入商品清单的顺序变化，虽然重新计算过程当中每次计算的结果和之前不同，但是当完成整个计算后，最终结果仍然和之前的计算结果一致。

动态规划并不是万能的，在这里我没有考虑各个商品之间的相互影响，比如说，如果我选择购买净水器，那么滤水壶的需求值就要降低，因为这两样商品的功能重复了。**仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。**并且使用动态规划解决类似购物问题时，要么买要么不买，假如你要买的是大米、小麦等等可以拆开只买一部分的东西，动态规划也没法解决。

总结起来，动态规划具有的特点是：

1. 需要在给定约束条件下优化某种指标时
2. 问题可以分解为离散的子问题时
3. 每种动态规划解决方案都涉及网格
4. 单元格中的值通常就是需要优化的值
5. 每个单元格都是一个子问题，因此需要考虑如何将问题分解为一个个子问题
6. 没有普遍使用的计算动态规划解决方案的公式
