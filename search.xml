<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS中this指向类型总结</title>
    <url>/2021/08/06/JS%E4%B8%ADthis%E6%8C%87%E5%90%91%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;在 JS 中，this 是在函数被调用时确定的，它的指向<strong>完全却决于函数调用的地方，而不是它被声明的地方(箭头函数除外)</strong>。当一个函数被调用时，会创建一个执行上下文，其中记录了函数在哪里被调用(调用栈)、函数的调用方式、传入的参数等信息，this 就是这个记录的一个属性，会在函数执行过程中被用到。</p>
<p>this 的指向分为以下几种场景：</p>
<ol>
<li>作为构造函数被 new 调用</li>
<li>作为对象的方法被调用</li>
<li>作为函数直接调用</li>
<li>被 call、apply、bind 调用</li>
<li>箭头函数中的 this</li>
</ol>
<span id="more"></span>
<h2 id="new-绑定，指向实例对象"><a href="#new-绑定，指向实例对象" class="headerlink" title="new 绑定，指向实例对象"></a>new 绑定，指向实例对象</h2><p>&emsp;&emsp;当函数作为构造函数使用 new 调用时，this 绑定的是新创建的构造函数的实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> Foo(); <span class="comment">// 输出Foo的实例，this就是bar</span></span><br></pre></td></tr></table></figure>
<h2 id="隐式绑定，指向上下文对象"><a href="#隐式绑定，指向上下文对象" class="headerlink" title="隐式绑定，指向上下文对象"></a>隐式绑定，指向上下文对象</h2><p>&emsp;&emsp;当函数作为对象的方法调用时，this 绑定到该上下文对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 输出world</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果嵌套了多个对象，那么 this 指向的是最后一个调用该方法的上下文对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.b.foo(); <span class="comment">// 输出 China</span></span><br></pre></td></tr></table></figure>
<h2 id="默认绑定，非严格模式下绑定到全局对象，严格模式下为-undefined"><a href="#默认绑定，非严格模式下绑定到全局对象，严格模式下为-undefined" class="headerlink" title="默认绑定，非严格模式下绑定到全局对象，严格模式下为 undefined"></a>默认绑定，非严格模式下绑定到全局对象，严格模式下为 undefined</h2><p>&emsp;&emsp;当函数被独立调用时，在非严格模式下，this 绑定到全局对象(浏览器下是 window，node 环境下是 global)，严格模式下，this 绑定到 undefined(因为严格模式不允许 this 指向全局对象)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 输出 hello, 浏览器中输出window对象，node环境下输出global对象</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;有时会遇到类似下面这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 输出 hello</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这时，虽然 bar 的值是 obj 对象的方法 foo，但是 bar 函数是独立调用的，因此属于默认绑定的情况，this 指向全局对象，这种情况和把方法作为回调函数的场景类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(obj.foo); <span class="comment">// 输出 hello</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数传递实际上是一种隐式赋值，这里将 obj.foo 方法隐式赋值给函数 func 的形参 fn，这类场景常见的有 setTimeout 和 setInterval，如果回调函数不是箭头函数，其中的 this 就指向全局对象。其实可以把默认绑定当作是隐式绑定的特殊情况，即把函数作为全局对象的方法进行调用，因此其中的 this 隐式绑定到全局对象。</p>
<h2 id="显示绑定，绑定到指定对象"><a href="#显示绑定，绑定到指定对象" class="headerlink" title="显示绑定，绑定到指定对象"></a>显示绑定，绑定到指定对象</h2><p>&emsp;&emsp;可以通过 call、apply、bind 修改函数绑定的 this，使其成为我们指定的对象，这些方法的第一个参数将显式的绑定 this：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(<span class="number">1</span>); <span class="comment">// 输出 3</span></span><br><span class="line">obj.foo.call(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, <span class="number">1</span>); <span class="comment">// 输出 5</span></span><br><span class="line">obj.foo.apply(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, [<span class="number">1</span>]); <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo.bind(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;call 和 apply 的区别是，call 方法接受参数列表，apply 方法接受参数数组，而 bind 方法则将第一个参数与 this 绑定，之后的参数作为原函数的参数序列的前若干项，返回一个新函数。</p>
<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><p>&emsp;&emsp;箭头函数中的 this 根据其声明的地方来决定 this 的指向，是当前所在词法作用域中的绑定，通常是箭头函数所在的函数作用域。箭头函数的 this 无法通过 call、apply、bind 进行修改，而且因为箭头函数没有构造函数 constructor，所以也不可以被 new 调用，即不能作为构造函数使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;this 存在多种使用场景，如果多个场景同时出现，this 会根据优先级来确定指向：<strong><em>new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</em></strong>。</p>
<p>&emsp;&emsp;因此，当我们要判断 this 的指向时，可以采用以下判断顺序和方法：</p>
<ol>
<li>new 绑定：函数是否由 new 调用？如果是则 this 绑定到新创建的对象实例</li>
<li>显式绑定：函数是否通过 call、apply、bind 调用？如果是则 this 绑定到指定的对象</li>
<li>隐式绑定：函数是否在某个上下文对象中调用？如果是则 this 绑定到这个上下文对象</li>
<li>默认绑定：如果以上都不是，在严格模式下 this 绑定为 undefined，在非严格模式下 this 绑定到当前环境的全局对象</li>
</ol>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的闭包与高阶函数</title>
    <url>/2021/08/06/JS%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;JS 中的函数是一等公民，可以和其他对象一样，有自己的属性和方法，可以赋值给一个变量，可以放进数组中作为元素，可以作为其他函数的参数,等等……普通对象能做的它能做，普通对象不能做的它也能做。因为 JS 中函数的这种特性，因而产生了很多特殊的情形，比如闭包和高阶函数。</p>
<span id="more"></span>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&emsp;&emsp;当函数可以<strong>记住并访问</strong>所在词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一般来说，函数在执行完后其整个内部作用域都会被销毁，因为 JavaScript 的 GC(Garbage Collection)垃圾回收机制会自动回收不再使用的内存空间。但是闭包会阻止某些 GC，比如上面例子中的 foo()执行完成后，因为返回的 bar 函数依然持有其所在作用域的引用，所以其内部作用域不会被回收。如果不是必须使用闭包，因该尽量避免产生闭包，因为闭包在处理速度和内存消耗方面对性能具有负面影响。</p>
<p>&emsp;&emsp;闭包的一个典型应用是备忘模式(结果缓存)。当一个函数存在复杂的执行过程，造成大量开销的话，可以在函数内部用一个对象来存储每次执行的结果，当下次执行时，如果用到同样的数据，就可以直接从这个缓存对象中取出数据，节省执行开销：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memories</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(rest);</span><br><span class="line">    <span class="keyword">return</span> _cache[key] || (_cache[key] = fn.apply(fn, rest));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的 JSON.stringify 把传给 memories 函数的参数序列化成字符串，把它当作_cache 的索引，将 memories 函数的运行结果当作索引的值传递给_cache，这样 memories 运行的时候，如果传递的参数之前传递过，那么就可以直接返回缓存好的结果，如果传递的参数没有使用过，则执行 memories 并将结果缓存。另外，还可以在实际使用时进行优化，一方面缓存不可以永远扩张下去，这样太耗费内存资源，可以设置只缓存最新传入的 n 个参数的结果，另一方面，可以借助浏览器的持久化手段进行缓存持久化，比如 cookie、localStorage 等。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>&emsp;&emsp;高阶函数即函数的输入参数中有函数，或者返回结果是函数。函数作为参数的情况，常见的场景就是回调函数，比如 setTimeout、setInterval 等，函数作为返回值的情况，常见的场景就是闭包的使用，利用闭包的特性来保持作用域。</p>
<p>&emsp;&emsp;下面列举几个高阶函数的常用情况：</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>&emsp;&emsp;柯里化(Currying)，又称部分求值(Partial Evaluation)，是把接受多个参数的原函数变换成接受一个单一参数(原函数的第一个参数)的函数，并且返回一个新函数，新函数能够接受余下的参数，最后返回同原函数一样的结果。柯里化的核心思想是把多参数传入的函数拆成单(或部分)参数函数，内部再返回调用下一个单(或部分)参数函数，依次处理剩余的参数。柯里化有 3 个常见作用：<strong>参数复用</strong>、<strong>提前返回</strong>、<strong>延迟计算/运行</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...rest1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(fn, rest1.concat(rest2));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h3><p>&emsp;&emsp;柯里化是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。反柯里化的意义和用法正好和柯里化相反，是为了扩大适用范围，创建一个应用范围更广的函数，使本来只有特定对象才适用的方法，扩展到更多的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(target, rest);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以这样理解柯里化和反柯里化的区别：柯里化是在运算前提前传参，可以传递多个参数；反柯里化是延迟传参，在运算时把原来已经固定的参数或者 this 上下文等当作参数延迟到未来传递。</p>
<h3 id="消抖函数"><a href="#消抖函数" class="headerlink" title="消抖函数"></a>消抖函数</h3><p>&emsp;&emsp;消抖函数(deBounce)可以在指定的间隔时间段内阻止原函数的重复执行，提高性能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>&emsp;&emsp;偏函数是创建一个调用另外一个部分(参数或变量已预制的函数)的函数，函数可以根据传入的参数来生成一个真正执行的函数。其本身不包括我们真正需要的代码，只是根据传入的参数返回其他函数，返回的函数中才有真正的处理逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isNumber = isType(<span class="string">&quot;Number&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isBoolean = isType(<span class="string">&quot;Boolean&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isUndefined = isType(<span class="string">&quot;Undefined&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isNull = isType(<span class="string">&quot;Null&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isObject = isType(<span class="string">&quot;Object&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isSymbol = isType(<span class="string">&quot;Symbol&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">&quot;Function&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样就利用偏函数快速创建了一组判断对象类型的方法。</p>
<p>&emsp;&emsp;偏函数和柯里化的区别：柯里化是把一个接受 n 个参数的函数，有原本的一次性传递所有参数并执行变成了可以分多次接受参数再执行；偏函数固定了函数的某个部分，通过传入的参数或者方法返回一个新的函数来接受剩余的参数，数量可能是一个也可能是多个；当一个柯里化函数只接受两次参数时，这时的柯里化函数和偏函数概念类似，可以认为偏函数是柯里化函数的退化版。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令与shell小技巧(一)</title>
    <url>/2021/08/11/Linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E5%B0%8F%E6%8A%80%E5%B7%A7-%E4%B8%80/</url>
    <content><![CDATA[<p>本文搜集记录了一些 Linux 下的命令和 shell 脚本使用技巧，内容主要来自：</p>
<blockquote><p>Linux Shell 脚本攻略（第 3 版）—— 门佳 译</p>
<footer><strong>[USA] Clif Flynt [IND] Sarath Lakshman [IND] Shantanu Tushar</strong><cite>Linux Shell Scripting Cookbook</cite></footer></blockquote>
<h2 id="基础知识和常用方法"><a href="#基础知识和常用方法" class="headerlink" title="基础知识和常用方法"></a>基础知识和常用方法</h2><h3 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h3><p>shebang，即通常情况下 shell 脚本的第一行，形如：<code>#!/bin/bash</code></p>
<p>其中，/bin/bash 是 Bash 的解释器路径，也可以指定为其他 shell，如/usr/bin/zsh。本行开头的#代表后面是一个注释。这一行的作用是定义了解释该脚本所使用的解释器，脚本中只有第一行可以使用 shebang 语句。</p>
<blockquote>
<p>shebang 这个词其实是两个字符名称(sharp-bang)的简写。在 Unix 中使用 sharp 或 hash 来称呼字符“#”，用 bang 来称呼惊叹号“!”，因而用 shebang 合起来代表这两个字符。</p>
</blockquote>
<p>实际使用中，如果我们将脚本作为解释器的命令行参数来使用，那么也可以不使用 shebang，但是当我们独立运行脚本文件时，系统则会使用 shebang 指定的解释器来执行脚本。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>和大多数脚本语言一样，shell 脚本可以直接使用赋值操作符(=)来定义变量而不需要声明类型，使用美元符号($)来使用变量。</p>
<blockquote>
<p>shell 中变量名由字母、数字、下划线组成，其中不包含空白字符，常用的惯例是使用大写字母命名环境变量，使用驼峰命名法或者小写字母命名其他变量</p>
<p><code>fruit=apple</code>定义变量，$fruit和${fruit}都可以使用变量，当形如 echo “${fruit}(s)”的时候，使用花括号的方式可以准确指定变量名称</p>
<p>对于单引号和双引号的区别，单引号不会扩展变量，即<code>echo &#39;$fruit&#39;</code>将显示$fruit，而双引号会扩展变量，即<code>echo &quot;$fruit&quot;</code>将显示 apple</p>
<p>使用形如<code>$&#123;#var&#125;</code>可以获得变量的长度，例如<code>echo &quot;$&#123;#fruit&#125;&quot;</code>将会显示 5</p>
</blockquote>
<p>shell 定义了一些变量用于保存用到的配置信息，例如可用的打印机、搜索路径等，这些变量称为<strong>环境变量</strong>，可以使用 env 或者 printenv 命令查看当前 shell 中定义的全部环境变量。</p>
<blockquote>
<p>使用环境变量<code>$SHELL</code>可以获知当前使用哪一种 shell，例如<code>echo &quot;$SHELL&quot;</code>显示/usr/bin/bash，也可以使用<code>echo &quot;$0&quot;</code>获得同样的结果</p>
<p>通过修改 shell 配置文件(例如.bashrc)里面的环境变量<code>$PS1</code>可以改变 shell 默认的提示字符串</p>
</blockquote>
<p>通过 shell 可以对变量进行简单的数学运算，下面是几个例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">n1=3</span><br><span class="line">n2=7</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> res1=n1+n2 <span class="comment"># 加号之间没有空格</span></span><br><span class="line">res2=$[ n1 + n2 ]</span><br><span class="line">res3=$(( n1 + n2 ))</span><br><span class="line">res4=`expr <span class="variable">$n1</span> + <span class="variable">$n2</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;n1: <span class="variable">$n1</span>,n2: <span class="variable">$n2</span>\nres1: <span class="variable">$res1</span>\nres2: <span class="variable">$res2</span>\nres3: <span class="variable">$res3</span>\nres4: <span class="variable">$res4</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># n1:3,n2:7</span></span><br><span class="line"><span class="comment"># res1: 10</span></span><br><span class="line"><span class="comment"># res2: 10</span></span><br><span class="line"><span class="comment"># res3: 10</span></span><br><span class="line"><span class="comment"># res4: 10</span></span><br></pre></td></tr></table></figure>
<p>以上方法只能计算整数值，如果要计算浮点值，可以使用 bc，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;4 * 0.56&quot;</span> | bc</span><br><span class="line"><span class="comment"># 2.24</span></span><br><span class="line">x1=54</span><br><span class="line">x2=1.5</span><br><span class="line">res=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$x1</span> * <span class="variable">$x2</span>&quot;</span> | bc`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$res</span>&quot;</span></span><br><span class="line"><span class="comment"># 81.0</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>echo 命令<br>echo 用于终端打印，每次调用后会添加一个换行符，可以使用-n 参数来禁止这种行为。使用-e 参数则可以将转义序列正确输出。echo 后面需要打印的内容，可以放入双引号、单引号、反引号中，也可以不使用引号。由于分号在 shell 中用作命令分隔符，因此不使用引号的时候，无法打印分号；放入单引号中的内容不会转移，变量不会扩展；放入双引号中的内容会被转移、变量会被扩展，因此特殊字符前需要使用反斜杠()；放入反引号中的内容，会开启子 shell 执行当中的命令。</p>
<p>printf 命令<br>printf 也可以用于终端打印，其参数和 C 语言中的 printf 函数一样。可以在 printf 中使用格式化字符串来指定字符串的宽度、左右对齐方式等。默认情况下 printf 不会自动添加换行符，需要手动添加。%s、%c、%d、%f 都是格式替换符。形如%-5s 中，-代表左对齐，不指定则默认为右对齐，5 指定保留字符串宽度为 5 个字符，不足则以空格填充。形如%4.2f 中.2 指定保留 2 位小数，总共保留 4 位。</p>
</blockquote>
<h3 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h3><p>文件描述符是与某个打开的文件或数据流相关联的整数，系统预留的文件描述符为 0、1、2，分别代表：</p>
<ul>
<li>0 —— stdin(标准输入)</li>
<li>1 —— stdout(标准输出)</li>
<li><p>2 —— stderr(标准错误)</p>
<p><code>&gt;</code>用于向文件中写入，会覆盖已有内容，<code>&gt;&gt;</code>则是向文件追加内容。当一条命令执行失败时，会返回一个非 0 的退出状态，而当命令成功执行后，会返回为 0 的退出状态，退出状态可以从特殊变量$?获得。当命令执行失败后，错误信息默认会输出到 stderr，可以通过<code>2&gt;</code>或<code>2&gt;&gt;</code>将 stderr 重定向到文件中，而使用<code>2&gt;&amp;1</code>则可以同时重定向 stdout 和 stderr。o</p>
<blockquote>
<p>特殊设备文件/dev/stdin、/dev/stdout、/dev/stderr 分别对应 stdin、stdout、stderr，还有一个<strong>黑洞</strong>，凡是进入的数据都将一去不复返，这就是/dev/null，这也是一个特殊设备文件，它会丢弃接受到的任何数据。</p>
</blockquote>
<p><code>&lt;</code>可以像 stdin 那样从文件中读取数据。</p>
</li>
</ul>
<h3 id="数组与关联数组"><a href="#数组与关联数组" class="headerlink" title="数组与关联数组"></a>数组与关联数组</h3><ul>
<li><p>定义数组：</p>
<ul>
<li><p>在单行中使用数值列表进行定义，这些值会存储在以 0 为起始索引的连续位置上。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_var=(test1 test2 test3)</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以将数组定义为一组“索引-值”：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_var[0]=<span class="string">&quot;test1&quot;</span></span><br><span class="line">array_var[1]=<span class="string">&quot;test2&quot;</span></span><br><span class="line">array_var[2]=<span class="string">&quot;test3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>打印出特定索引的数组元素内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[0]&#125;</span></span><br><span class="line"><span class="comment"># test1</span></span><br><span class="line">index=2</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[$index]&#125;</span></span><br><span class="line"><span class="comment"># test3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以列表形式打印出数组中的所有值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[*]&#125;</span></span><br><span class="line"><span class="comment"># test1 test2 test3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_var[@]&#125;</span></span><br><span class="line"><span class="comment"># test1 test2 test3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打印数组长度(元素个数)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array_var[*]&#125;</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义关联数组</p>
<p>在关联数组中，可以使用任意文本作为数组索引。要定义关联数组，首先需要将一个变量声明为关联数组：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A fruits_value</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用行内“索引-值”列表：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fruits_value=([apple]=<span class="string">&#x27;100 dollars&#x27;</span> [orange]=<span class="string">&#x27;150 dollars&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用独立的“索引-值”进行赋值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fruits_value[apple]=<span class="string">&#x27;100 dollars&#x27;</span></span><br><span class="line">fruits_value[orange]=<span class="string">&#x27;150 dollars&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关联数组的其他操作方法则与普通数组一样，只需要将数字索引改为使用文本索引即可</p>
</li>
</ul>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名提供了一种便捷的方式来调用命令，省去了输入一长串命令的麻烦。别名通过<code>alias</code>创建，例如<code>alias lsa=&quot;ls -alhF&quot;</code>，别名的效果是暂时的，通过将别名定义放入 shell 配置文件中(例如.bashrc)可以使别名长期生效。当创建别名时，如果有同名的别名存在，则旧的别名会被覆盖。要删除别名，可以使用<code>unalias</code>，也可以通过使用如<code>alias lsa=</code>的方式取消。单独使用<code>alias</code>命令可以显示当前所有别名，后面跟上别名名称，则可以显示对应别名的内容。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>使用<code>date</code>命令可以读取和设置时间。使用-s 参数用于设置指定时间；使用带有前缀+的格式化字符串的参数则可以按指定格式打印出当前时间；使用+%s 可以得到 Unix 纪元时。</p>
<blockquote>
<p><em>tips</em>：date 命令的最小单位是秒，如果要对命令计时，因该使用 time 命令</p>
<p>Unix 纪元时被定义为从世界标准时间 UTC，1970 年 1 月 1 日 0 时 0 分 0 秒起至当前时刻的总秒数，不包含闰秒。</p>
</blockquote>
<p>下面列出 date 命令支持的格式化字符串参数：</p>
<ul>
<li>%y — 年，例如：21</li>
<li>%Y — 年，例如：2021</li>
<li>%b — 月，例如：Nov</li>
<li>%B — 月，例如：November</li>
<li>%d — 日，例如：11</li>
<li>%D — 特定格式日期(mm/dd/yy)，例如：08/11/21</li>
<li>%a — 工作日(weekday)，例如：Sat</li>
<li>%A — 工作日(weekday)，例如：Saturday</li>
<li>%H — 时，例如：08</li>
<li>%M — 分，例如：33</li>
<li>%S — 秒，例如：17</li>
<li>%N — 纳秒，例如：660561200</li>
<li>%s — Unix 纪元时，以秒为单位，例如：1628694257</li>
</ul>
<p><code>sleep</code>命令可以设置延迟时间，以秒为单位，例如以下脚本可以间隔 3 秒输出”Hello World!”：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">for</span> count <span class="keyword">in</span> `seq 1 3`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Count: <span class="variable">$count</span> -- Hello World!&quot;</span></span><br><span class="line">  sleep 3</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Count: 1 -- Hello World!</span></span><br><span class="line"><span class="comment"># 间隔3秒</span></span><br><span class="line"><span class="comment"># Count: 2 -- Hello World!</span></span><br><span class="line"><span class="comment"># 间隔3秒</span></span><br><span class="line"><span class="comment"># Count: 3 -- Hello World!</span></span><br><span class="line"><span class="comment"># 间隔3秒，脚本执行完成</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面脚本中，<code>for count in <code>seq 1 3</code></code>也可以写成<code>for count in (1..3)</code>，这个语言构件执行速度比 seq 命令略快</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li><p>定义函数</p>
<p>函数的定义包括 function 命令、函数名、一对圆括号以及使用一对花括号包含的函数体。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fname</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用函数</p>
<p>直接使用函数名就可以实现函数调用。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fname;</span><br></pre></td></tr></table></figure>
<p>函数支持递归调用，必须注意递归调用一定要有退出条件，否则将导致系统资源耗尽或崩溃。</p>
<blockquote>
<p>Fork 炸弹，该函数会在后台不断的衍生出新进程<br><code>: () &#123; : | :&amp; &#125;;:</code></p>
</blockquote>
</li>
<li><p>参数</p>
<ul>
<li>$0 脚本名</li>
<li>$1、$2、…$n 脚本第 1 个参数、第 2 个参数…第 n 个参数</li>
<li>$* 脚本所有参数，被扩展成”$1c$2c…$n”，其中 c 为 IFS 的第一个字符</li>
<li>$@ 脚本所有参数，以列表形式扩展，”$1” “$2” … “$n”</li>
</ul>
<blockquote>
<p><code>$@</code>要比<code>$*</code>用得多，因为<code>$*</code>将所有参数扩展成一个字符串</p>
</blockquote>
<p>大多数应用都能接受不同的参数执行相应的操作，可以通过使用<code>shift</code>命令来实现。该命令可以将参数依次往左移动一位，这样就可以循环使用<code>$1</code>来取得所有参数。</p>
</li>
<li><p>返回值</p>
<p>在函数体中使用<code>return</code>语句返回值，返回值被称为退出状态，按照惯例，函数成功执行完毕，应该返回 0 作为退出状态，否则因该返回一个非 0 值。退出状态可以通过特殊变量<code>$?</code>取得。</p>
</li>
<li><p>导出函数</p>
<p>可以使用<code>export -f fname</code>到处函数，这样函数的作用域就可以被扩展到子 shell 中。</p>
</li>
</ol>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>Unix shell 最棒的特性就是可以轻松的将多个命令组合起来完成复杂的任务，一个命令的输出作为下一个命令的输入，依次传递。这种情况下，这些命令称为过滤器 filter，使用管道 pipe 可以将每个过滤器连接起来。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure>
<p>通过管道配和子 shell 的方式，我们可以从多个命令组合取得结果，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls | cat -n &gt; out.txt</span><br><span class="line"><span class="comment"># 列出当前目录的内容并且加上行号，结果将存入out.txt文件</span></span><br></pre></td></tr></table></figure>
<p>另一种实现方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmd_out=$(ls | cat -n)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$cmd_out</span></span><br></pre></td></tr></table></figure>
<p>还有一种实现方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmd_output=`ls | cat -n`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$cmd_output</span></span><br></pre></td></tr></table></figure>
<p>以上几种方式都可以获得组合命令的结果，其中第二种采用的就是子 shell，通过<code>$()</code>可以生成一个子 shell，子 shell 是一个独立的进程，因此当命令在子 shell 中执行时，不会对当前 shell 造成影响，例如在子 shell 中使用<code>cd</code>命令切换目录，不会改变当前 shell 中的工作目录。</p>
<p>如果要将反引号或子 shell 方式获得的结果保存到变量或文件中，需要注意结果中的空格和换行符要通过使用双引号来保留，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test.txt</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">out=$(cat test.txt)</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 丢失换行符</span></span><br><span class="line">res=<span class="string">&quot;<span class="subst">$(cat test.txt)</span>&quot;</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 正确保留了换行符</span></span><br></pre></td></tr></table></figure>
<h3 id="从键盘或标准输入读取"><a href="#从键盘或标准输入读取" class="headerlink" title="从键盘或标准输入读取"></a>从键盘或标准输入读取</h3><p><code>read</code>命令可以让程序从键盘或标准输入读取数据：</p>
<ul>
<li>read -n char_number var 读取 n 个字符并存入变量</li>
<li>read -s var 使用无回显的方式读取输入存入变量</li>
<li>read -p “message” var 给出提示信息</li>
<li>read -t timeout var 限定有效输入时间(秒)</li>
<li>read -d delimiter_char var 使用指定的定界符从输入中读取数据存入变量，使用这种方法可以让我们不必按回车键也可以录入数据</li>
</ul>
<h3 id="持续运行命令直至成功"><a href="#持续运行命令直至成功" class="headerlink" title="持续运行命令直至成功"></a>持续运行命令直至成功</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">repeat</span></span> () &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="variable">$@</span> &amp;&amp; <span class="built_in">return</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数通过一个死循环反复调用以函数参数形式($@)传入的命令，直到命令成功执行，才会退出循环。</p>
<blockquote>
<p>上面的函数定义中，可以把<code>while true</code>替换成<code>while :;</code>，其中<code>:;</code>是 shell 内建命令，总是返回 0 作为退出状态，性能比使用 true 要好</p>
</blockquote>
<h3 id="IFS"><a href="#IFS" class="headerlink" title="IFS"></a>IFS</h3><p>IFS，即内部字段分隔符，它是一个环境变量，其中保存了用于分隔的字符，它是当前 shell 环境默认使用的定界字符串。在处理字符串或者逗号分隔型数值(csv)是很有用，IFS 默认值是空白字符(换行符、空格或制表符)。我们可以这样来使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">oldIFS=<span class="variable">$IFS</span></span><br><span class="line">IFS=, <span class="comment"># 以逗号作为分隔符</span></span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;do something&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">IFS=<span class="variable">$oldIFS</span></span><br></pre></td></tr></table></figure>
<h3 id="比较与测试"><a href="#比较与测试" class="headerlink" title="比较与测试"></a>比较与测试</h3><ol>
<li><p>if</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>if…else</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&amp;&amp;和||</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ condition ] &amp;&amp; action <span class="comment"># 如果condition为真，执行action</span></span><br><span class="line">[ condition ] || action <span class="comment"># 如果condition为假，执行action</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>test 命令</p>
<p><code>test</code>命令同样可以用来测试条件，通过调用 test 命令可以避免条件判断时使用过多的括号，增强代码可读性。另一方面，test 作为一个外部命令，使用时会衍生出对应的进程，而括号是 Bash 内建的函数，执行效率比 test 命令更高。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令与shell小技巧(三)</title>
    <url>/2021/08/22/Linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E5%B0%8F%E6%8A%80%E5%B7%A7-%E4%B8%89/</url>
    <content><![CDATA[<p>本文搜集记录了一些 Linux 下的命令和 shell 脚本使用技巧，内容主要来自：</p>
<blockquote><p>Linux Shell 脚本攻略（第 3 版）—— 门佳 译</p>
<footer><strong>[USA] Clif Flynt [IND] Sarath Lakshman [IND] Shantanu Tushar</strong><cite>Linux Shell Scripting Cookbook</cite></footer></blockquote>
<h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><p><code>echo -e &quot;this is a word\nnext line&quot; | grep word</code>使用 grep 从标准输入中搜索匹配特定模式的文本行</p>
<p><code>grep pattern file</code>或<code>grep &quot;pattern&quot; file</code>从文件中搜索匹配特定模式的文本行</p>
<p><code>grep &quot;pattern&quot; file1 file2 file3</code>同时从多个文件中搜索</p>
<p><code>grep --color=auto &quot;pattern&quot; file</code>在输出中着重标记出匹配到的模式，参数—color 对在命令中的放置位置没有强制要求，但是通常作为第一个选项出现</p>
<p><code>grep -E &quot;[a-z]+&quot; file</code>或者<code>egrep &quot;[a-z]+&quot; file</code>使用扩展的正则表达式进行搜索，而 grep 默认使用基础正则表达式</p>
<p><code>grep -o &quot;pattern&quot; file</code>只输出匹配到的文本</p>
<p><code>grep -v &quot;pattern&quot; file</code>输出不匹配的所有行</p>
<p><code>grep -c &quot;pattern&quot; file</code>统计成功匹配的文本行数，加上参数<code>-v</code>可以反转匹配结果，统计不匹配的文本行数</p>
<blockquote>
<p>使用<code>-c</code>参数只是统计出成功匹配的文本行数，而不是匹配的次数，如果要统计匹配的次数，可以使用如下的技巧：</p>
<p><code>grep -o &quot;pattern&quot; | wc -l</code></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 1wds</span></span><br><span class="line"><span class="comment"># 2sdsad</span></span><br><span class="line"><span class="comment"># 3sds4sd</span></span><br><span class="line"><span class="comment"># 5dsd6da</span></span><br><span class="line">egrep -c <span class="string">&quot;[0-9]+&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">egerp -o <span class="string">&quot;[0-9+]&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line">egrep -o <span class="string">&quot;[0-9]+&quot;</span> <span class="built_in">test</span> | wc -l</span><br><span class="line"><span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>grep -n &quot;pattern&quot; file</code>可以显示出匹配行的行号，<code>grep -n &quot;pattern&quot; file1 file2</code>如果有多个文件时，会加上文件名和行号</p>
<p><code>grep -b &quot;pattern&quot; file</code>输出匹配行的偏移量，<code>grep -bo &quot;pattern&quot; file</code>则会输出匹配结果的偏移量，偏移量是从 0 开始计算的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 1wds</span></span><br><span class="line"><span class="comment"># 2sdsad</span></span><br><span class="line"><span class="comment"># 3sds4sd</span></span><br><span class="line"><span class="comment"># 5dsd6da</span></span><br><span class="line">egrep -b <span class="string">&quot;[0-9]+&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 0:1wds</span></span><br><span class="line"><span class="comment"># 5:2sdsad</span></span><br><span class="line"><span class="comment"># 12:3sds4sd</span></span><br><span class="line"><span class="comment"># 20:5dsd6da</span></span><br><span class="line">egrep -bo <span class="string">&quot;[0-9]+&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 0:1</span></span><br><span class="line"><span class="comment"># 5:2</span></span><br><span class="line"><span class="comment"># 12:3</span></span><br><span class="line"><span class="comment"># 16:4</span></span><br><span class="line"><span class="comment"># 20:5</span></span><br><span class="line"><span class="comment"># 24:6</span></span><br></pre></td></tr></table></figure>
<p><code>grep -l &quot;pattern&quot; file1 file2</code>列出匹配成功的文件列表，<code>grep -L &quot;pattern&quot; file1 file2</code>则列出没有匹配的文件列表</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test1</span><br><span class="line"><span class="comment"># 1wds</span></span><br><span class="line"><span class="comment"># 2sdsad</span></span><br><span class="line"><span class="comment"># 3sds4sd</span></span><br><span class="line"><span class="comment"># 5dsd6da</span></span><br><span class="line">cat test2</span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 56</span></span><br><span class="line">egrep -l <span class="string">&quot;[a-z]+&quot;</span> test1 test2</span><br><span class="line"><span class="comment"># test1</span></span><br><span class="line">egrep -L <span class="string">&quot;[a-z]+&quot;</span> test1 test2</span><br><span class="line"><span class="comment"># test2</span></span><br></pre></td></tr></table></figure>
<p><code>grep &quot;pattern&quot; path -R</code>会在指定路径中递归的搜索</p>
<p><code>grep -i &quot;pattern&quot; file</code>搜索时忽略大小写</p>
<p><code>grep -e &quot;pattern1&quot; -e &quot;pattern2&quot; file</code>可以同时指定多个匹配模式</p>
<p><code>grep -f pattern_file file</code>可以从文件中读取匹配模式(一个匹配模式一行)，然后进行搜索</p>
<p><code>grep &quot;pattern&quot; path -R --include &quot;pattern&quot;</code>可以在搜索过程中用通配符指定某些文件，相反的，参数<code>--exclude</code>在搜索过程中使用通配符排除某些文件，<code>--exclude-dir</code>可以排除目录</p>
<p><code>grep -Z &quot;pattern&quot; file</code>可以使用 0 值字符(\0)作为文件名的终结符，结合参数<code>-l</code>或<code>-L</code>可以搜索出特定文件，然后传递给 xargs 执行下一步操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;pattern&quot;</span> -lZ . -R | xargs -0 rm</span><br></pre></td></tr></table></figure>
<p><code>grep -q &quot;pattern&quot; file</code>使用静默模式搜索，不会输出搜索结果，只会在执行搜索后返回退出码，执行成功返回退出码 0，否则返回非 0 退出码</p>
<p><code>grep -A n &quot;pattern&quot; file</code>可以输出匹配行以及之后的 n 行，<code>grep -B n &quot;pattern&quot; file</code>可以输出匹配行和之前的 n 行</p>
<p><code>grep -A n -B m &quot;pattern&quot; file</code>可以输出匹行以及之前的 m 行和之后的 n 行</p>
<p><code>grep -C n &quot;pattern&quot; file</code>可以输出匹配行和前后 n 行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># xxx</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># abc</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># xxx</span></span><br><span class="line">grep -A 2 <span class="string">&quot;abc&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># abc</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># xxx</span></span><br><span class="line">grep -B 2 <span class="string">&quot;abc&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># xxx</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># abc</span></span><br><span class="line">grep -C 2 <span class="string">&quot;abc&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># xxx</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># abc</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># xxx</span></span><br><span class="line">grep -A 2 -B 1 <span class="string">&quot;abc&quot;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># abc</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># xxx</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Scrapy时提取一个块级标签下的所有文本的正确方式</title>
    <url>/2021/04/05/%E4%BD%BF%E7%94%A8Scrapy%E6%97%B6%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%AA%E5%9D%97%E7%BA%A7%E6%A0%87%E7%AD%BE%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E6%9C%AC%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>使用 Scrapy 爬取一篇博客的内容(<a href="https://www.cnblogs.com/flashsun/p/14266148.html">原文链接</a>)，这里忽略正文中的图片，只针对文本内容。</p>
<p>博客正文内容位于标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;cnblogs_post_body&quot;</span> <span class="attr">class</span>=<span class="string">&quot;blogpost-body blogpost-body-html&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>你是<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>一台电脑，你的名字叫 A<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      如果你纠结，要么去研究一下操作系统是如何处理网络 IO</span><br><span class="line">      的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在</span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>开枪<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      吧~</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第三层<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  ...... ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可见，正文内容内部的结构比较复杂，没有一致可循的规律，那么怎样提取其中所有的文本内容呢？</p>
<span id="more"></span>
<p>第一步，先选择 id=cnblogs_post_body 的 div 标签，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;cnblogs_post_body&quot;</span> <span class="attr">class</span>=<span class="string">&quot;blogpost-body blogpost-body-html&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开终端，使用 Scrapy Shell 测试，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy shell https://www.cnblogs.com/flashsun/p/14266148.html</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; post_body=response.xpath(<span class="string">&#x27;//div[@id=&quot;cnblogs_post_body&quot;]&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; post_body</span><br><span class="line">&gt;&gt;&gt; [&lt;Selector xpath=<span class="string">&#x27;//div[@id=&quot;cnblogs_post_body&quot;]&#x27;</span> data=<span class="string">&#x27;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;bl...&#x27;</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>然后，尝试使用 text()和 getall()获取所有文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; post_body.xpath(<span class="string">&#x27;.//text()&#x27;</span>).getall()</span><br><span class="line">&gt;&gt;&gt; [<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;你是&#x27;</span>, <span class="string">&#x27;一台电脑，你的名字叫 A&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;直到有一天，你</span></span><br><span class="line"><span class="string">希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根&#x27;</span>, <span class="string">&#x27;网线&#x27;</span>, <span class="string">&#x27;连接了起来。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;用一根网线连接起来怎么就能&quot;通信&quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在&#x27;</span>, <span class="string">&#x27;开枪&#x27;</span>, <span class="string">&#x27;吧~&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;反正，你们就是连起来了，并且可以通信。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;第一层&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开&#x27;</span>, <span class="string">&#x27;两个网口&#x27;</span>, <span class="string">&#x27;，用一共&#x27;</span>, <span class="string">&#x27;三根网线&#x27;</span>, <span class="string">&#x27;，彼此相连。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的</span></span><br><span class="line"><span class="string">我就用红色虚线表示了，就是这么严谨哈哈~）&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;你给它取名叫&#x27;</span>, <span class="string">&#x27;集线器&#x27;</span>, <span class="string">&#x27;，它仅仅是无脑将电信号&#x27;</span>, <span class="string">&#x27;转发到所有出口（广播）&#x27;</span>, <span class="string">&#x27;，不做任何处理，你觉得它是没有智商的，因此把人家定性在了&#x27;</span>, <span class="string">&#x27;物理层&#x27;</span>, <span class="string">&#x27;。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;首先，你要给所有的连接到交换机的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，&#x27;</span>, <span class="string">&#x27;全局唯一&#x27;</span>, <span class="string">&#x27;的名字作为标识，你把这个更高端的名字称为\xa0&#x27;</span>, <span class="string">&#x27;MAC 地址&#x27;</span>, <span class="string">&#x27;。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;这样，A 在发送数据包给 B 时，只要在头部拼接</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......]</span></span><br></pre></td></tr></table></figure>
<p>得到结果是一个所有文本的列表，或者说是当前 div 元素下所有文本节点的集合，那么怎样才能将结果拼接成一篇完整的博客内容呢？</p>
<p>最直接暴力的办法当然是通过循环迭代将列表中所有元素拼接起来，这里不在赘述。其实在 XPath 中原生提供了 string()函数来转换字符串，下面尝试使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; post_body.xpath(<span class="string">&#x27;string(.//text())&#x27;</span>).getall()</span><br><span class="line">&gt;&gt;&gt; [<span class="string">&#x27;\n&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>什么鬼？！好好的一大篇文章就剩下一个换行……</p>
<p>一开始我也只好倒回去老老实实写 for…in…，直到后来翻看官方文档才找到问题所在：</p>
<blockquote>
<p>When you need to use the text content as argument to an XPath string function, avoid using .//text() and use just . instead.</p>
</blockquote>
<p>当我们使用.//text()时，所得到的是一个 node-set，把一个 node-set 传递给 string()进行字符串转换的时候，只会作用于 node-set 中的第一个元素，类似的情况还有使用 contains()和 starts-width()，而这里 post_body 中的第一个元素正好就是”\n”！</p>
<p>而如果将一个 node 进行字符串转换，就会将该节点以及其子孙节点中的文本进行拼接，因此在这个例子中，我们因该直接对 post_body 使用 string()：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; post_body.xpath(<span class="string">&#x27;string(.)&#x27;</span>).getall()</span><br><span class="line">&gt;&gt;&gt; [<span class="string">&#x27;\n\xa0\n你是一台电脑，你的名字叫 A\n\xa0\n很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。\n\n直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。\n\n\xa0\n用一根网线连接起来怎么就能&quot;通信&quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。\n如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~\n\n反正，你们就是连起来了，并且可以通信。\n\xa0\n第一层\n\xa0\n有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。\n\n随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就</span></span><br><span class="line"><span class="string">用红色虚线表示了，就是这么严谨哈哈~）\n\n于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。\n\n你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此</span></span><br><span class="line"><span class="string">把人家定性在了物理层。\n\xa0\n由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？\n首先，你要给所有的连接到交换机的设备，都起个名字。原</span></span><br><span class="line"><span class="string">来你们叫 ABCD，但现在需要一</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">，于是收下了这个包\n\xa0\n更详细且精准的过程：\n读到这相信大家已经很累了，理解上述过程基本上网络层以下的部分主流程就基本疏通了，如果你想要本过程更为专业的过程描述，可以在公众号 低并发编程 后台回复 网络，获得我模拟这个过程的 Cisco Packet Tracer 源文件。\n\n每一步包的传输都 会有各层的原始数据，以及专业的过程描述\n\n\xa0\n\xa0\n同时在此基础之上你也可以设计自己的网络拓扑结构，进行各种实验，来加深网络传输过程的理解。\n\xa0\n后记\n\xa0\n至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。\n\n本文经过了很多次的修改，删减了不少影响主流程的内容，就是为了让读者能抓住网络传输前三层的真正核心思想。同时网络相关 的知识也是多且杂，我也还有很多搞不清楚的地方，非常欢迎大家与我交流，共同进步。\n&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>哈哈，这次终于正确返回了一篇完整的博客文本内容！当然，在这里我们可以直接使用 get()而不是 getall()，因为 string(.)会自动将当前节点和其子孙节点的文本进行拼接，这样就可以获得一个字符串方便直接使用。</p>
<p>在官方文档中还列举了一个使用 contains()对节点文本内容进行匹配的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from scrapy import Selector</span><br><span class="line">&gt;&gt;&gt; sel=Selector(text=<span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; sel.xpath(<span class="string">&#x27;//a[contains(.//text(),&#x27;</span>Next Page<span class="string">&#x27;)]&#x27;</span>).getall()</span><br><span class="line">&gt;&gt;&gt; []</span><br><span class="line">&gt;&gt;&gt; sel.xpath(<span class="string">&#x27;//a[contains(.,&#x27;</span>Next Page<span class="string">&#x27;)]&#x27;</span>).getall()</span><br><span class="line">&gt;&gt;&gt; [<span class="string">&#x27;&lt;a href=&quot;#&quot;&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>使用.//text()时，得到的结果其实只有 a 中的第一个文本节点，即：”Click here to go to the “，因此无法匹配文本”Next Page”，而使用节点本身，得到的是当前节点和其子孙节点的所有文本内容的拼接，即：”Click here to go to the Next Page”，因此成功匹配。</p>
<p>最后，放上 Scrapy 官方文档中，本文相关内容的<a href="https://docs.scrapy.org/en/latest/topics/selectors.html#using-text-nodes-in-a-condition">链接</a></p>
]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Scrapy爬取诗词数据</title>
    <url>/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>在本篇中我将使用 Scrapy 来开发一个简单的文本爬虫，从<a href="https://www.zhsc.net">中华诗词网</a>上爬取诗词数据。</p>
<p>首先对目标网站进行分析，在其主页右下角有一个历代作者的链接入口，从该链接可以进入作者列表页面，如下图中红圈所示：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/index.png" class="">
<span id="more"></span>
<p>接下来进入作者列表页面，可以看见在页面下方有一个“历代作者”面板区域，其中按历史时期进行划分，收录了各个时代的文人，如下图红圈所示：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/authorlist.png" class="">
<p>打开开发者面板对页面内容进行分析，可以看到该页面包含了所有作者的链接，只不过页面上仅显示当前选中历史时期下的作者列表，而未选中的部分默认使用<code>style=&quot;display:none;&quot;</code>隐藏了起来，如下图红圈所示：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/dom.png" class="">
<p>仔细浏览以下上面的作者列表页可以发现，中华诗词网收录的文人非常多，而每个人又有很多诗词作品，如果一次全部爬取数据量太大，不仅耗时，而且在不使用代理 IP 的情况下，容易被封，更重要的是，对于传统诗词人们的学习和关注重心都在历史上的著名文人上，而对于全部收录数据来说，这些著名文人的作品只是一小部分。</p>
<p>因此，我将爬虫设计为只对指定的作者进行爬取，而要实现这一点，正好可以从上面的作者列表页作为种子页面启动爬虫。从该页中的所有作者条目中匹配出指定的作者，然后再链接到诗词列表页面，如下图所示：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/poemlist.png" class="">
<p>从诗词列表中，就可以通过每一项的链接到达我们真正要爬取数据的诗词详情页，同时由于某些文人作品很多，采用了分页，因此还需要匹配分页器中的链接地址，依次从所有诗词列表页面中达到详情页爬取数据。</p>
<p>这里需要注意，很多作者都有和别人同名的作品，而且某个作者自己也可能有很多同名的作品，这种情况尤其常见于宋词当中：词牌名相同，正文不同，如上图中红圈所示，柳永名下同为“黄莺儿”的词作便有两首。这里便要考虑爬取数据之后，怎样存取才更方便日后使用的时候查询数据，在这里我使用标识宋词常用的方法：标题=词牌名+正文首句。</p>
<p>最后，来分析我们最终需要爬取数据的诗词详情页，如下图所示，需要爬取的数据有：标题、年代、作者和正文：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/poem.png" class="">
<p>打开开发者工具，仔细分析页面结构，可以看出，需要爬取的数据全部位于<code>class=&quot;shi_neirong&quot;</code>的 <code>&lt;div&gt;</code> 标签下的<code>class=&quot;zh_shi_xiang1&quot;</code>的 <code>&lt;div&gt;</code> 标签内，该 <code>&lt;div&gt;</code> 标签包括一个 <code>&lt;span&gt;</code> 标签、一个 <code>&lt;p&gt;</code> 标签和一个 <code>&lt;div&gt;</code> 标签，其中 <code>&lt;span&gt;</code> 标签中的是标题，<code>&lt;p&gt;</code> 标签中则同时包含了年代和作者，而 <code>&lt;div&gt;</code> 标签中的是正文，如下图所示：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/poem1dom.png" class="">
<p>接下来在随机打开多个详情页，确认页面结构是否符合上面的分析，这里为了节省篇幅，只列举出一个和上面详情页稍有不同的页面，如下图所示：</p>
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/poem2.png" class="">
<img src="/2021/05/02/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE/poem2dom.png" class="">
<p>首先从页面上观察可以发现两处不同，一是正文内容中出现了<code>&lt;p&gt;</code>，二是正文中多了很多蓝色的文字。</p>
<p>打开开发者工具分析，首先从页面整体结构上看，数据所在的标签位置和层次关系仍然符合上面的分析，如图中横线所示。其次，第一个不同点，多出来的<code>&lt;p&gt;</code>应该是网站后台数据处理错误，将 html 的 <code>&lt;p&gt;</code> 标签以文本存入了诗词数据中，那么我们之后爬取数据时，应该要对数据进行去 html 标签的处理，第二个不同点，可以看出是对诗文内容的注解，以<code>&lt;span&gt;</code>标签的形式插入到正文所在的<code>&lt;div&gt;</code>标签中，注解不是我们需要的数据，之后爬取时应该过滤掉，如图中红圈所示。</p>
<p>到这里，对于目标网站的分析基本完成，那么下面开始着手编写爬虫。</p>
]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Scrapy爬取诗词数据（续）</title>
    <url>/2021/05/03/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
    <content><![CDATA[<p>在上一篇文章中，我们已经完成了对目标网站的分析(<a href="https://www.zhsc.net">中华诗词网</a>)，接下来开始进行爬虫开发。</p>
<p>首先启动一个新项目，搭建基本目录结构，这里推荐使用 virtualenv 创建 python 虚拟环境进行开发。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir poems_crawler &amp;&amp; cd $_</span><br><span class="line"></span><br><span class="line">virtualenv -p Python3 venv</span><br><span class="line"></span><br><span class="line">. venv/bin/activate</span><br></pre></td></tr></table></figure>
<p>以上命令创建了一个 poems_crawler 空目录，并进入目录启激活 python3 虚拟环境。</p>
<p>接下来安装 scrapy 并创建一个 zhsc_crawler 的项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install scrapy3</span><br><span class="line"></span><br><span class="line">scrapy startproject zhsc_crawler</span><br></pre></td></tr></table></figure>
<p>到这里，我们使用 scrapy 新建了一个 zhsc_crawler 项目，在当前目录下多出了一个名为 zhsc_crawler 的项目根目录，进入项目目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zhsc_crawler</span><br></pre></td></tr></table></figure>
<p>查看目录结构可以看到在项目根目录下还有一个同名的目录<code>zhsc_crawler</code>，以及一个名为 scrapy.cfg 的 scrapy 配置文件。这里的<code>zhsc_crawler</code>目录就是爬虫项目的包目录，这里也是之后我们自己编写代码的地方，其下包含了 items.py(Item 定义文件)、middlewares.py(自定义中间件)、pipelines.py(自定义管道)、settings.py(项目配置文件)和一个名为<code>spiders</code>的目录，这是放置爬虫类的包目录。</p>
<span id="more"></span>
<p>现在来创建我们的蜘蛛类：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider poems www.zhsc.net</span><br></pre></td></tr></table></figure>
<p>现在在<code>spiders</code>目录下会生成一个 poems.py 文件，我们在这里来编写蜘蛛。</p>
<p>首先修改其中的<code>start_urls</code>，也就是爬虫开始发起请求的地址，根据前面的分析，种子页应该是作者列表页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_urls=[<span class="string">&#x27;https://www.zhsc.net/Index/shi_more.html&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>现在来编写处理种子页响应的代码，在<code>poems.py</code>中，对<code>start_urls</code>发起的请求，其响应会被<code>parse</code>方法处理，因此先来看看在<code>parse</code>方法里面怎么写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">author=<span class="built_in">getattr</span>(self,<span class="string">&#x27;author&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>前面说过，爬虫将被设计为爬取指定作者的诗词数据，在 scrapy 中提供了通过 scrapy cli 向蜘蛛中动态传入参数的功能，其方式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl poems -a author=李白</span><br></pre></td></tr></table></figure>
<p>通过<code>-a</code>选项传入的参数会被传递给蜘蛛类的<code>__init__</code>方法成为蜘蛛实例上的一个属性，因此通过 getattr 方法便可以获取由命令行传入的参数。</p>
<p>下一步，对作者列表进行筛选，匹配指定的作者。</p>
<p>首先因该从页面中提取所有作者的链接，在 scrapy 中可以使用 xpath 和 css 两种方式来获取 html 内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">author_links=response.css(<span class="string">&#x27;.ci_lei1&gt;.ci_lei1&gt;.ci_lei1_xuan&gt;.ci_lei1_xuan2 a&#x27;</span>).getall()</span><br></pre></td></tr></table></figure>
<p><code>response.css</code>是使用 scrapy 的 css 选择器获取 html 内容，得到的结果可以通过<code>get</code>和<code>getall</code>方法来取得第一项匹配结果或所有匹配结果的列表。这里使用<code>getall</code>得到当前页面包含的所有作者链接。</p>
<p>接下来从所有作者中匹配指定的作者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> author <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">  <span class="keyword">for</span> link <span class="keyword">in</span> author_links:</span><br><span class="line">    poems_list_page_url=find_author_url(link,author)</span><br><span class="line">    <span class="keyword">if</span> poems_list_page_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">yield</span> response.follow(poems_list_page_url,self.parse_list)</span><br><span class="line"><span class="keyword">return</span> ZhscCrawlerItem()</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>for...in</code>遍历作者列表来进行匹配，这里引入的自定义的方法<code>find_author_url</code>，如果调用该方法成功返回了链接地址，则使用 scrapy 提供的<code>response.follow</code>方法让蜘蛛沿着指定的链接继续爬取，最后<code>return ZhscCrawlerItem()</code>是返回爬取到的数据，这是新建爬虫项目时，scrapy 自动为我们在<code>items.py</code>中生成的数据类，稍后我们会在这里对爬取数据进行定义。</p>
<p>先来看看自定义的<code>find_author_url</code>方法，其定义在项目目录下的<code>processors.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_author_url</span>(<span class="params">link,author</span>):</span></span><br><span class="line">  <span class="keyword">if</span> re.search(<span class="string">r&#x27;&gt;\s*&#123;&#125;\s*&lt;&#x27;</span>.<span class="built_in">format</span>(author),link) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> re.search(<span class="string">r&#x27;(?:href\s*\=\s*&quot;)(.+?)(?:&quot;)&#x27;</span>,link).group(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>逻辑很简单，使用正则先匹配指定作者，如果找到则返回其链接，否则返回<code>None</code>。</p>
<p>现在如果我们传入作者名字并且假定这是一个被收录在目标网站中的作者，那么蜘蛛将会进入诗词列表页面，下面来看看怎么编写处理诗词列表页面的方法<code>parse_list</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">detail_urls=response.css(<span class="string">&#x27;.zh_sou_jie&gt;.zh_jie_con a::attr(href)&#x27;</span>).getall()</span><br></pre></td></tr></table></figure>
<p>scrapy 的 css 选择器使用<code>::attr</code>的语法来提取 html 标签中的属性，这里首先提取当前诗词列表页面中的所有诗词详情页地址。然后让蜘蛛跟随详情页链接，进入下一步详情页爬取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> detail_urls:</span><br><span class="line">  <span class="keyword">yield</span> response.follow(url,self.parse_item)</span><br></pre></td></tr></table></figure>
<p>之前分析过，诗词详情由于条目众多，目标网站使用了分页器，因此在诗词列表页的处理中还因该让蜘蛛跟随分页器的链接继续爬取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">next_page_urls=response.css(<span class="string">&#x27;.page a::attr(href)&#x27;</span>).getall()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> next_page_urls:</span><br><span class="line">  <span class="keyword">yield</span> response.follow(url,self.parse_list)</span><br></pre></td></tr></table></figure>
<p>到这一步，蜘蛛应该可以顺利到达所有的诗词详情页，接下来编写蜘蛛的核心代码，对数据页的爬取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">  loader=ItemLoader(item=ZhscCrawlerItem(),response=response)</span><br></pre></td></tr></table></figure>
<p>这里使用了两个新类<code>ItemLoader</code>和<code>ZhscCrawlerItem</code>，上面提到过，<code>ZhscCrawlerItem</code>是新建爬虫时 scrapy 自动为我们创建的数据类，而<code>ItemLoader</code>则是 scrapy 为我们提供的数据处理类，可以直接引入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br></pre></td></tr></table></figure>
<p>首先来定义数据类，根据前文分析，要爬取的数据主要包含标题 title、年代 times、作者 author 和正文 content，在项目目录下的<code>items.py</code>中定义数据结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itemloaders.processors <span class="keyword">import</span> Join,MapCompose,TakeFirst</span><br><span class="line"><span class="keyword">from</span> scrapy.item <span class="keyword">import</span> Field,Item</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .processors <span class="keyword">import</span> get_author,get_times,parse_content</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhscCrawlerItem</span>(<span class="params">Item</span>):</span></span><br><span class="line">  title=Field(input_processor=MapCompose(<span class="built_in">str</span>.strip,stop_on_none=<span class="literal">True</span>),output_processor=TakeFirst())</span><br><span class="line">  times=Field(input_processor=MapCompose(get_times,stop_on_none=<span class="literal">True</span>),output_processor=TakeFirst())</span><br><span class="line">  author=Field(input_processor=MapCompose(get_author,stop_on_none=<span class="literal">True</span>),output_processor=TakeFirst())</span><br><span class="line">  content=Field(input_processor=MapCompose(parse_content,stop_on_none=<span class="literal">True</span>),output_processor=Join(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>scrapy 中定义数据结构使用<code>Item</code>和<code>Field</code>基类，使用语法<code>字段名=Field()</code>来规定数据因该包含的字段。</p>
<p>前文中已经分析过，对详情页中原始的标题、年代、作者和正文数据因该先进行处理，让我们回顾一下：</p>
<ol>
<li>标题要修改为原始标题加上正文内容的第一句</li>
<li>年代和作者信息位于同一个<code>&lt;p&gt;</code>标签内，要分别进行提取</li>
<li>正文结构不尽相同，有些诗词正文中还带有注释内容，需要进行过滤</li>
</ol>
<p>在scrapy中当我们要爬取指定页面时，首先会由spider发起一个爬虫请求给scrapy engine，然后engine将请求添加到scheduler的调度队列，当接到scheduler的响应后engine通知downloader对指定url开始下载数据，完成下载之后，将数据交给spider解析。</p>
<p>所以对于上面需要进行的数据处理，就可以放在spider对downloader下载回来的数据进行解析的时候。</p>
<p>在<code>Field</code>中，使用<code>input_processor</code>和<code>output_processor</code>就可以分别在downloader下载完数据时进行处理，以及在spider解析完数据向后传递给pipeline之前进行处理。而<code>itemloaders.processors</code>中提供了<code>Join</code>、<code>MapCompose</code>和<code>TakeFirst</code>三个数据处理方法，其中<code>Join</code>和<code>TakeFirst</code>用于<code>output_processor</code>，顾名思义，这两个方法分别用于将数据列表中的每一项合并后输出，和获取数据列表中的第一项输出。</p>
<p><code>MapCompose</code>方法用于<code>input_processor</code>，可以传入多个方法，<code>MapCompose</code>会将获取的数据依次传递给这些方法处理，然后将结果交给向后传递。由于获取的原始数据可能是一个列表，比如上面的诗词正文，在详情页中，正文是位于一个<code>&lt;div&gt;</code>标签下的多个文本节点组成的，因此通过 scrapy 的 css 选择器得到的是一个列表，假如列表中某一项为空值，而我们指定的处理方法可能无法处理输入值为空的情况，这是便会报错，所以可以在<code>MapCompose</code>中指定<code>stop_on_none=True</code>来规定遇到空值时停止继续处理。</p>
<p><code>get_author</code>、<code>get_times</code>和<code>parse_content</code>是<code>processors.py</code>中的三个自定义的处理函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_author</span>(<span class="params">value</span>):</span></span><br><span class="line">  result=re.search(<span class="string">r&#x27;(?:作者:\s*)(.*)(?:\s*)&#x27;</span>,value)</span><br><span class="line">  <span class="keyword">return</span> result.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_times</span>(<span class="params">value</span>):</span></span><br><span class="line">  result=re.search(<span class="string">r&#x27;(?:年代:\s*)(.+?)(?:\s)&#x27;</span>,value)</span><br><span class="line">  <span class="keyword">return</span> result.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_content</span>(<span class="params">value</span>):</span></span><br><span class="line">  value=remove_tags(value.strip())</span><br><span class="line">  <span class="keyword">return</span> re.sub(<span class="string">r&#x27;(。|！|？)&#x27;</span>,<span class="string">r&#x27;\1\n&#x27;</span>,value)</span><br></pre></td></tr></table></figure>
<p>这里使用了 python 标准库<code>w3lib</code>里面的 remove_tags 方法去除 html 标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> w3lib.html <span class="keyword">import</span> remove_tags</span><br></pre></td></tr></table></figure>
<p><code>re.sub(r&#39;(。|！|？)&#39;,r&#39;\1\n&#39;,value)</code>在句号或感叹号或问号后面添加一个换行，这是为了符合阅读诗词时的习惯：在一个完整的诗句后面换行。</p>
<p>在这里并没有对标题进行处理(将标题修改为原始标题加上正文第一句)，因为在这里主要是定义数据结构，使用<code>input_processor</code>和<code>output_processor</code>的目的是正确提取数据，规范数据内容，而对标题的处理属于项目设计的需求，因此将放到后面自定义管道中再进行。</p>
<p>回到蜘蛛<code>poems.py</code>中，现在处理详情页的方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">  loader=ItemLoader(item=ZhscCrawlerItem(),response=response)</span><br></pre></td></tr></table></figure>
<p>接着往下，向<code>loader</code>中传入定义的字段数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loader.add_css(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;.zh_shi_xiang1&gt;span::text,.zh_shi_xiang1&gt;span&gt;*::text&#x27;</span>)</span><br><span class="line">loader.add_css(<span class="string">&#x27;times&#x27;</span>, <span class="string">&#x27;.zh_shi_xiang1&gt;p::text&#x27;</span>)</span><br><span class="line">loader.add_css(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;.zh_shi_xiang1&gt;p::text&#x27;</span>)</span><br><span class="line">loader.add_css(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;.zh_shi_xiang1&gt;div::text,.zh_shi_xiang1&gt;div&gt;*::text&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> loader.load_item()</span><br></pre></td></tr></table></figure>
<p><code>loader.add_css</code>方法使用 scrapy 的 css 选择器将 html 中的内容添加到在<code>ZhscCrawlerItem</code>中定义的指定字段，最后使用<code>loader.load_item</code>方法将获取的数据返回，这里要注意使用<code>add_css</code>方法后，只是 item 的指定字段注入数据，但是数据并不会被返回，所以在完成向所有字段注入数据后，一定要调用<code>load_item</code>方法将数据返回。</p>
]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>网络爬虫中常用的数据提取工具</title>
    <url>/2021/04/05/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>在网络爬虫开发中，需要对返回的响应内容进行分析提取，常见的工具主要有 Beautiful Soup、PyQuery 以及框架 Scrapy 自带的 Selector，他们之间有何区别以及新上手开发爬虫该如何选择呢？</p>
<h3 id="Beautiful-Soup-和-pyQuery"><a href="#Beautiful-Soup-和-pyQuery" class="headerlink" title="Beautiful Soup 和 pyQuery"></a>Beautiful Soup 和 pyQuery</h3><p>Beautiful Soup 目前最新版本为 bs4，和 PyQuery 对比，在使用中二者语法大同小异，如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Beautiful Soup4</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BlogsItem</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">    soup=BeautifulSoup(response.body,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    item=BlogsItem()</span><br><span class="line">    item[<span class="string">&#x27;title&#x27;</span>]=soup.select(<span class="string">&#x27;#mainContent .postTitle2.vertical-middle&#x27;</span>).text()</span><br><span class="line">    item[<span class="string">&#x27;description&#x27;</span>]=soup.select(<span class="string">&#x27;#mainContent .c_b_p_desc).text()</span></span><br><span class="line"><span class="string">    item[&#x27;</span>pub_date<span class="string">&#x27;]=soup.select(&#x27;</span><span class="comment">#mainContent .dayTitle&gt;span).text()</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PyQuery</span></span><br><span class="line"><span class="keyword">from</span> pyQuery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BlogsItem</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">    doc=pq(response.body)</span><br><span class="line">    item=BlogsItem()</span><br><span class="line">    item[<span class="string">&#x27;title&#x27;</span>]=doc(<span class="string">&#x27;#mainContent .postTitle2.vertical-middle&#x27;</span>).text()</span><br><span class="line">    item[<span class="string">&#x27;description&#x27;</span>]=doc(<span class="string">&#x27;#mainContent .c_b_p_desc&#x27;</span>).text()</span><br><span class="line">    item[<span class="string">&#x27;pub_date&#x27;</span>]=doc(<span class="string">&#x27;#mainContent .dayTitle&gt;span&#x27;</span>).text()</span><br></pre></td></tr></table></figure>
<p>相对于 PyQuery 而言，Beautiful Soup 年代更久远，成熟度更高，文档完善，但是其性能较差，尤其在爬取任务量巨大(爬取量在万级以上)时，会有比较明显的速度滞后感，而且对内存的消耗也比较大。PyQuery 比 bs4 性能要更好一些，而且其提供类似 jQuery 的语法，对于熟悉前端技术的用户来说非常容易上手。</p>
<h3 id="Scrapy-Selector"><a href="#Scrapy-Selector" class="headerlink" title="Scrapy Selector"></a>Scrapy Selector</h3><p>除了上述两种流行的第三方库，在爬虫框架 Scrapy 中还原生提供了两种选择器：XPath 和 CSS。</p>
<ol>
<li><p>XPath</p>
<p>XPath，全称 XML Path Language，即 XML 路径语言。XPath 用于在 XML 文档中通过元素和属性进行导航，同样适用于 HTML。</p>
<p>XPath 使用路径表达式在文档中进行导航，语法简介明了，并且包含有超过 100 个内建函数用于字符串、数值、日期和时间比较，以及节点处理、序列处理、逻辑值判断等，XPath 也是一个 W3C 标准。</p>
<p>使用 XPath 几乎可以准确定位所有节点。</p>
<p>XPath 的常用规则主要是：</p>
<ul>
<li>nodename：选取此节点的所有子节点</li>
<li>/：从当前节点选取直接子节点</li>
<li>//：从当前节点选取子孙节点</li>
<li>.：选取当前节点</li>
<li>..：选取当前节点的父节点</li>
<li>@：选取属性，也可以进行属性匹配，如 div[@id=”post_title”]</li>
<li>text()：获取文本</li>
<li>contains()：属性多值匹配，如 div[contains(@id,”post_title”)]</li>
<li>[and]：多属性匹配，如 div[contains(@id,”post_title”) and @class=”post-item”]</li>
</ul>
<p>XPath 的常用运算符：</p>
<ul>
<li>or：逻辑或</li>
<li>and：逻辑与</li>
<li>mod：求余数</li>
<li>|：求节点集</li>
<li>+/-/*/div：加减乘除</li>
<li>=/!=：等于、不等于</li>
<li>&lt; /&lt;= / &gt; / &gt;=：小于、小于等于，大于，大于等于</li>
</ul>
<p>XPath 还支持按序选择：</p>
<ul>
<li>‘//li[1]/text()’：获取第一个 li</li>
<li>‘//li[last()]/text()’：获取最后一个 li</li>
<li>‘//li[position()&lt;3]/text()’：获取前 2 个 li</li>
<li>‘//li[last()-2]/text()’：获取倒数第二个 li</li>
</ul>
<p>更多的使用方法可以查阅 XPath 相关文档，下面是一个使用示例，从<a href="https://www.cnblogs.com">博客园</a>的<a href="https://www.cnblog.com/pick/">精华</a>频道爬取文章标题、内容摘要、作者和发布时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogsSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;blogs&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;zzk.cnblogs.com/&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.cnblogs.com/pick/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># use xpath selector</span></span><br><span class="line">        <span class="keyword">for</span> post <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//div[@id=&quot;post_list&quot;]//article[has-class(&quot;post-item&quot;)]&#x27;</span>):</span><br><span class="line">            title = post.xpath(<span class="string">&#x27;.//a[has-class(&quot;post-item-title&quot;)]/text()&#x27;</span>).get()</span><br><span class="line">            link = post.xpath(<span class="string">&#x27;.//a[has-class(&quot;post-item-title&quot;)]/@href&#x27;</span>).get()</span><br><span class="line">            summary = post.xpath(<span class="string">&#x27;.//p[has-class(&quot;post-item-summary&quot;)]/text()&#x27;</span>).getall()[-<span class="number">1</span>].strip()</span><br><span class="line">            author = post.xpath(<span class="string">&#x27;.//a[has-class(&quot;post-item-author&quot;)]/span/text()&#x27;</span>).get()</span><br><span class="line">            publish = post.xpath(<span class="string">&#x27;.//span[has-class(&quot;post-meta-item&quot;)]/span/text()&#x27;</span>).get()</span><br><span class="line">            next_page_url = response.xpath(<span class="string">&#x27;//div[@id=&quot;pager_bottom&quot;]//a/@href&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> &#123;<span class="string">&#x27;文章标题&#x27;</span>: title, <span class="string">&#x27;原文链接&#x27;</span>: link, <span class="string">&#x27;内容摘要&#x27;</span>: summary, <span class="string">&#x27;作者&#x27;</span>: author, <span class="string">&#x27;发布时间&#x27;</span>: publish&#125;</span><br><span class="line">            <span class="keyword">if</span> next_page_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> response.follow(next_page_url, callback=self.parse)</span><br></pre></td></tr></table></figure>
<p>部分爬取结果如图：</p>
<img src="/2021/04/05/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E5%B7%A5%E5%85%B7/result.png" class="">
</li>
<li><p>CSS</p>
<p>如果你不懂 XPath 语法，还可以使用 CSS 选择器，CSS 选择器拥有接近于 XPath 选择器的速度，因为 Scrapy 会将 CSS 选择器转换为 XPath。在 scrapy.Selector.css 方法中会调用 Selector 的内部方法_css2xpath，这是一个自动将 css 选择器语法转换成 xpath 语法的私有方法。</p>
<p>下面是使用 css 选择器语法改写上面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogsSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;blogs&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;zzk.cnblogs.com/&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.cnblogs.com/pick/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># use css selector</span></span><br><span class="line">        <span class="keyword">for</span> post <span class="keyword">in</span> response.css(<span class="string">&#x27;div#post_list article.post-item&#x27;</span>):</span><br><span class="line">            title = post.css(<span class="string">&#x27;a.post-item-title::text&#x27;</span>).get()</span><br><span class="line">            link = post.css(<span class="string">&#x27;a.post-item-title::attr(href)&#x27;</span>).get()</span><br><span class="line">            summary = post.css(<span class="string">&#x27;p.post-item-summary::text&#x27;</span>).getall()[-<span class="number">1</span>].strip()</span><br><span class="line">            author = post.css(<span class="string">&#x27;a.post-item-author&gt;span::text&#x27;</span>).get()</span><br><span class="line">            publish = post.css(<span class="string">&#x27;span.post-meta-item&gt;span::text&#x27;</span>).get()</span><br><span class="line">            next_page_url = response.css(<span class="string">&#x27;div#pager_bottom a::attr(href)&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> &#123;<span class="string">&#x27;文章标题&#x27;</span>: title, <span class="string">&#x27;原文链接&#x27;</span>: link, <span class="string">&#x27;内容摘要&#x27;</span>: summary, <span class="string">&#x27;作者&#x27;</span>: author, <span class="string">&#x27;发布时间&#x27;</span>: publish&#125;</span><br><span class="line">            <span class="keyword">if</span> next_page_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> response.follow(next_page_url, callback=self.parse)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果使用 Scrapy 进行爬虫开发，推荐使用 Scrapy 提供的 XPath 选择器或者 CSS 选择器，无需额外引入第三方库，并且速度很快。而在 Beautiful Soup 和 PyQuery 之间，可以选择性能更好的 PyQuery，对于有 jQuery 使用经验的用户来说尤其方便快速上手。</p>
]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>通过动态规划算法解决618最佳购物方案</title>
    <url>/2021/04/05/%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3618%E6%9C%80%E4%BD%B3%E8%B4%AD%E7%89%A9%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>最近刚装修完新房，新家种种东西方方面面都亟待采买，正好还有两个多月便是 618，打算趁着促销活动，购置一批生活家电。</p>
<p>看着各大网购平台上琳琅满目的商品，各种宣传导购、直播带货，感觉每样东西不是吊炸天便是亮瞎眼，恨不能来者不拒，买买买…，奈何囊中羞涩，为了不至于“一波买买买，稀饭喝到腿发软”，只好提前计划，理性消费。</p>
<p>首先规划好消费总额，暂定为只使用信用卡额度的 70%。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TOTAL_ASSETS = <span class="number">10000</span>  <span class="comment"># 总资产</span></span><br><span class="line">RATE = <span class="number">0.7</span>  <span class="comment"># 使用百分比</span></span><br><span class="line">AVAILABLE_ASSET = TOTAL_ASSETS*RATE  <span class="comment"># 可用资产</span></span><br></pre></td></tr></table></figure>
<p>接下来需要列出商品清单，这里要考虑好以什么作为参考来判断最后得出的购买清单是最优的，以及以什么作为参数来选择商品。</p>
<p>首先，既然限制了消费总额，因此使用商品的价格来作为选择与否的依据；其次，对于每样商品，会有一个需求度的期望值，也就是说该商品是否急需使用。举个例子，如果将需求度按 1 到 10 来划分，冰箱的需求度是 10(家里面总是会有东西需要冷藏)，而破壁机的需求度是 5(平时做点鲜果汁、热豆浆什么的，营养又健康，但是没有的话对生活影响不会太大)。那么，最后的购买清单便以尽可能达到最大需求度为最优解。</p>
<p>下面列出商品清单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COMMODITY_LIST = &#123;</span><br><span class="line">    <span class="string">&#x27;苏泊尔电饭煲&#x27;</span>: (<span class="number">319</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="string">&#x27;海尔净水器&#x27;</span>: (<span class="number">1188</span>, <span class="number">8</span>),</span><br><span class="line">    <span class="string">&#x27;海尔智能门锁&#x27;</span>: (<span class="number">1399</span>, <span class="number">9</span>),</span><br><span class="line">    <span class="string">&#x27;九阳破壁机&#x27;</span>: (<span class="number">449</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">&#x27;海尔智能音箱&#x27;</span>: (<span class="number">199</span>, <span class="number">3</span>),</span><br><span class="line">    <span class="string">&#x27;海尔冰箱&#x27;</span>: (<span class="number">3199</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="string">&#x27;海尔滚筒洗衣机&#x27;</span>: (<span class="number">2699</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="string">&#x27;格力空气循环扇&#x27;</span>: (<span class="number">399</span>, <span class="number">6</span>),</span><br><span class="line">    <span class="string">&#x27;苏泊尔电压力锅&#x27;</span>: (<span class="number">259</span>, <span class="number">7</span>),</span><br><span class="line">    <span class="string">&#x27;碧然德滤水壶&#x27;</span>: (<span class="number">219</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态规划的原理是从小问题着手，然后逐步解决大问题。在这里，可以对总金额进行划分，比如先假设只能使用 100 块，然后找出当前的最佳购买方式，接着再假设只能使用 200 块，此时已经知道了使用 100 块时的最佳购买方式，只需要在此基础上看看使用 200 块能多买到什么东西，然后和上一次的计算结果进行比较，就可以轻松得出可以使用 200 块时的最佳购买方式，以此类推。</p>
<span id="more"></span>
<p>使用动态规划通常都会伴随着使用网格。首先建立一张表格，其中每一行都对应一种商品，每一列对应当前假设可以使用的金额，单元格中的数值就是获得的需求值。每个单元格的初始值为 0，即当前还没有选择购买任何商品。这里为了方便演示，只列出前 10 列，即最大可用金额为 1000，如下图：</p>
<img src="/2021/04/05/%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3618%E6%9C%80%E4%BD%B3%E8%B4%AD%E7%89%A9%E6%96%B9%E6%A1%88/new.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_shopping_list</span>(<span class="params">money, commodities</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    指定可用金额作为约束条件，从提供的可选商品中选择出最佳选择方式，获取最多的需求值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    current_asset = [</span><br><span class="line">        i+<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(money), <span class="number">100</span>)]  <span class="comment"># 将可用资产以100为最小单位进行划分</span></span><br><span class="line">    commodity_names = <span class="built_in">list</span>(commodities.keys())  <span class="comment"># 所有可选商品</span></span><br><span class="line">    selected_goods = [[<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> current_asset]</span><br><span class="line">                      <span class="keyword">for</span> _ <span class="keyword">in</span> commodity_names]  <span class="comment"># 每个单元格中选中的商品，初始为空</span></span><br><span class="line">    table = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> current_asset]</span><br><span class="line">             <span class="keyword">for</span> _ <span class="keyword">in</span> commodity_names]  <span class="comment"># 用于动态规划计算的网格</span></span><br></pre></td></tr></table></figure>
<p>现在，可以开始进行动态规划计算：</p>
<ol>
<li><p>首先，查看当前行对应商品的价格，将其与每一列的可用金额进行对比，这里可能出现两种情况：</p>
<ol>
<li><p>当前可用金额小于商品价格：</p>
<p>这种情况下，不能选择该商品，那么单元格中的值就应该是上一次计算所得。对于第一行，也就是第一次计算来说，保持单元格中的值不动。</p>
</li>
<li><p>当前可用金额大于等于商品价格：</p>
<p>这种情况下，可以选择购买该商品，让我们来计算可以获得多少需求值：</p>
<ol>
<li><p>第一步，查看该商品的需求值<strong>“当前商品需求值”</strong></p>
</li>
<li><p>第二步，计算余额，即如果选择购买该商品，还剩多少钱可用，<strong>“当前余额”</strong> = <strong>“当前可用金额”</strong> - <strong>“当前商品价格”</strong></p>
</li>
<li><p>第三步，计算余额可获得的需求值，<strong>“余额可得需求值”</strong> = <strong>“上一行”</strong>和<strong>“最接近余额的可用金额所在列”</strong>对应的单元格中的需求值。</p>
<p>举例来说，假设现在计算第四行“九阳破壁机（449，5）”和最后一列“￥ 1000.00”，那么购买破壁机后，余额等于 1000 - 449 = 551，那么余额可得需求值应该查找第三行第 5 列(￥ 500.00)单元格中的值。假如我们现在计算的是第四行第五列，那么余额等于 500 - 449 = 51，而最小可用金额是 100，说明余额已经不足最小可计算的可用金额，那么余额可得需求值就为 0。类似的，当第一次计算时，选择当前商品后，无论剩多少钱，都没有东西可选，即余额可得需求值也为 0。</p>
</li>
<li><p>第四步，计算选择该商品后可以获得的需求值，<strong>“选择当前商品可得需求值”</strong> = <strong>“当前商品需求值”</strong> + <strong>“余额可得需求值”</strong></p>
</li>
<li><p>第五步，查看当前可用金额下上一次计算的结果，<strong>“上一次计算结果”</strong> = <strong>“本列上一行”</strong>对应单元格中的需求值</p>
<p>当计算第一行时，即第一次计算，上一次计算结果可以认为是 0，即单元格中的初始需求值。</p>
</li>
<li><p>最后一步，比较<strong>“选择当前商品可得需求值”</strong>和<strong>“上一次计算结果”</strong>，如果<strong>“上一次计算结果需求值更大”</strong>，则将当前单元格更新为<strong>“上一次计算结果”</strong>，否则，将当前单元格更新为<strong>“选择当前商品可得需求值”</strong>。这里注意要同步更新选择的商品。</p>
</li>
</ol>
<img src="/2021/04/05/%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3618%E6%9C%80%E4%BD%B3%E8%B4%AD%E7%89%A9%E6%96%B9%E6%A1%88/step1.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_cells</span>(<span class="params">row, column</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   更新单元格的方法，传入当前单元格的行、列数</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   current_commodity = commodity_names[row]  <span class="comment"># 当前商品名</span></span><br><span class="line">   (price, grade) = commodities[current_commodity]  <span class="comment"># 当前商品价格和需求值</span></span><br><span class="line">   asset = current_asset[column]  <span class="comment"># 当前可用金额</span></span><br><span class="line">   <span class="keyword">if</span> row == <span class="number">0</span>:  <span class="comment"># 第一次计算的时候</span></span><br><span class="line">         <span class="keyword">if</span> asset &gt;= price:  <span class="comment"># 当前可用金额大于等于当前商品价格</span></span><br><span class="line">            table[row][column] = grade  <span class="comment"># 更新当前单元格数值</span></span><br><span class="line">            selected_goods[row][column].add(</span><br><span class="line">               current_commodity)  <span class="comment"># 更新当前单元格选择商品</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">if</span> asset &gt;= price:  <span class="comment"># 当前可用金额大于等于当前商品价格</span></span><br><span class="line">            remaining_asset = asset-price  <span class="comment"># 剩余金额</span></span><br><span class="line">            <span class="comment"># 最大的剩余可用金额，这里比如手中还剩371，则对应最大的剩余可用金额是300</span></span><br><span class="line">            max_remaining_available_asset = (remaining_asset//<span class="number">100</span>)*<span class="number">100</span></span><br><span class="line">            remaining_asset_index = -<span class="number">1</span> <span class="keyword">if</span> max_remaining_available_asset == <span class="number">0</span> <span class="keyword">else</span> current_asset.index(</span><br><span class="line">               max_remaining_available_asset)</span><br><span class="line">            <span class="comment"># 剩余金额可以获得的需求值</span></span><br><span class="line">            remainder_grade = table[commodity_index -</span><br><span class="line">                                    <span class="number">1</span>][remaining_asset_index] <span class="keyword">if</span> remaining_asset_index &gt; -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            current_total_grade = grade+remainder_grade  <span class="comment"># 当前商品需求值和剩余金额可获得需求值之和</span></span><br><span class="line">            <span class="comment"># 本列上一行单元格的值，即当前可用金额下，前一次计算所得的最大需求值</span></span><br><span class="line">            prev_grade = table[row-<span class="number">1</span>][column]</span><br><span class="line">            <span class="keyword">if</span> current_total_grade &gt;= prev_grade:  <span class="comment"># 更新当前单元格</span></span><br><span class="line">               table[row][column] = current_total_grade</span><br><span class="line">               <span class="keyword">if</span> remaining_asset_index &gt; -<span class="number">1</span>:  <span class="comment"># 选择当前商品后，并且剩余金额大于等于100</span></span><br><span class="line">                     prev_selected_goods = selected_goods[row -</span><br><span class="line">                                                         <span class="number">1</span>][remaining_asset_index].copy()</span><br><span class="line">                     prev_selected_goods.add(current_commodity)</span><br><span class="line">                     <span class="comment"># 更新当前单元格选择的商品</span></span><br><span class="line">                     selected_goods[row][column] = prev_selected_goods</span><br><span class="line">               <span class="keyword">else</span>:  <span class="comment"># 选择当前商品后，剩余金额不足100</span></span><br><span class="line">                     selected_goods[row][column] = &#123;</span><br><span class="line">                        current_commodity&#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               table[row][column] = table[row-<span class="number">1</span>][column]</span><br><span class="line">               selected_goods[row][column] = selected_goods[row -</span><br><span class="line">                                                            <span class="number">1</span>][column].copy()</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当前可用金额小于当前商品价格时</span></span><br><span class="line">            <span class="comment"># 更新当前单元格需求值为上一次计算结果</span></span><br><span class="line">            table[row][column] = table[row-<span class="number">1</span>][column]</span><br><span class="line">            <span class="comment"># 更新当前单元格选择商品为上一次计算结果</span></span><br><span class="line">            selected_goods[row][column] = selected_goods[row -</span><br><span class="line">                                                         <span class="number">1</span>][column].copy()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>查看下一行，并且依照上面的方法更新单元格。</p>
<img src="/2021/04/05/%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3618%E6%9C%80%E4%BD%B3%E8%B4%AD%E7%89%A9%E6%96%B9%E6%A1%88/step2.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> commodity_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(commodity_names)):  <span class="comment"># 遍历每一行，即每种可选商品</span></span><br><span class="line">   <span class="keyword">for</span> asset_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(current_asset)):  <span class="comment"># 遍历每一列，即每一档可用金额</span></span><br><span class="line">      update_cells(commodity_index, asset_index)  <span class="comment"># 更新单元格</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终，当我们更新完最后一个单元格时，整个动态规划算法结束，最后一个单元格的需求值就是我们求得的最优解，对应选择的商品就是最佳购物方式。</p>
<img src="/2021/04/05/%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3618%E6%9C%80%E4%BD%B3%E8%B4%AD%E7%89%A9%E6%96%B9%E6%A1%88/last.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;<span class="string">&#x27;选择的商品&#x27;</span>: selected_goods[-<span class="number">1</span>][-<span class="number">1</span>], <span class="string">&#x27;获得的需求值&#x27;</span>: table[-<span class="number">1</span>][-<span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>最终计算出的结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;选择的商品&#x27;</span>: &#123;<span class="string">&#x27;海尔滚筒洗衣机&#x27;</span>, <span class="string">&#x27;海尔智能门锁&#x27;</span>, <span class="string">&#x27;海尔智能音箱&#x27;</span>, <span class="string">&#x27;海尔净水器&#x27;</span>, <span class="string">&#x27;格力空气循环扇&#x27;</span>, <span class="string">&#x27;碧然德滤水壶&#x27;</span>, <span class="string">&#x27;苏泊尔电压力锅&#x27;</span>, <span class="string">&#x27;苏泊尔电饭煲&#x27;</span>&#125;,</span><br><span class="line"><span class="string">&#x27;获得的需求值&#x27;</span>: <span class="number">58</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在我又有几件商品想要购买，那么可以继续加入表格中，从新添加的行开始，照上面的方法继续计算，最终仍然可以得到最优解，而且即使打乱各行的顺序，即可选商品加入商品清单的顺序变化，虽然重新计算过程当中每次计算的结果和之前不同，但是当完成整个计算后，最终结果仍然和之前的计算结果一致。</p>
<p>动态规划并不是万能的，在这里我没有考虑各个商品之间的相互影响，比如说，如果我选择购买净水器，那么滤水壶的需求值就要降低，因为这两样商品的功能重复了。<strong>仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</strong>并且使用动态规划解决类似购物问题时，要么买要么不买，假如你要买的是大米、小麦等等可以拆开只买一部分的东西，动态规划也没法解决。</p>
<p>总结起来，动态规划具有的特点是：</p>
<ol>
<li>需要在给定约束条件下优化某种指标时</li>
<li>问题可以分解为离散的子问题时</li>
<li>每种动态规划解决方案都涉及网格</li>
<li>单元格中的值通常就是需要优化的值</li>
<li>每个单元格都是一个子问题，因此需要考虑如何将问题分解为一个个子问题</li>
<li>没有普遍使用的计算动态规划解决方案的公式</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令与shell小技巧(二)</title>
    <url>/2021/08/13/Linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E5%B0%8F%E6%8A%80%E5%B7%A7-%E4%BA%8C/</url>
    <content><![CDATA[<p>本文搜集记录了一些 Linux 下的命令和 shell 脚本使用技巧，内容主要来自：</p>
<blockquote><p>Linux Shell 脚本攻略（第 3 版）—— 门佳 译</p>
<footer><strong>[USA] Clif Flynt [IND] Sarath Lakshman [IND] Shantanu Tushar</strong><cite>Linux Shell Scripting Cookbook</cite></footer></blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><p><code>cat file1 file2 file3 ...</code>将多个文件内容进行拼接并显示到 stdout。</p>
<p>可以通过管道操作符(|)将数据作为 cat 命令的输入，然后和另外的文件拼接显示：</p>
<p><code>echo &quot;Text through stdin&quot; | cat - file</code>将从标准输入获取的数据和文件 file 的内容拼接起来显示，其中-被作为标准输入的文件名。</p>
<p><code>cat -s file</code>可以去掉文件中的连续空行再进行显示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;test\n\ntest\n\ntest&quot;</span> | cat</span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;test\n\ntest\n\ntest&quot;</span> | cat -s</span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># test</span></span><br></pre></td></tr></table></figure>
<p><code>test -T file</code>可以将制表符(\t)显示为^I，有助于发现缩进错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;test\ttest&quot;</span> | cat</span><br><span class="line"><span class="comment"># test  test</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;test\ttest&quot;</span> | cat -T</span><br><span class="line"><span class="comment"># test^Itest</span></span><br></pre></td></tr></table></figure>
<p><code>cat -n file</code>可以为每一行加上行号显示，默认会为空行也加上行号</p>
<p><code>cat -nb file</code>只为非空行添加上号显示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;test\n\ntest\n\ntest&quot;</span> | cat -n</span><br><span class="line"><span class="comment"># 1 test</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3 test</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5 test</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;test\n\ntest\n\ntest&quot;</span> | cat -nb</span><br><span class="line"><span class="comment"># 1 test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 3 test</span></span><br></pre></td></tr></table></figure>
<h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><p><code>find base_path</code>列出给定目录下的所有文件和子目录</p>
<p>find 命令默认将结果进行打印，可以使用<code>-print</code>选项来显示指定，默认情况下(-print)会使用换行符(\n)来分隔每个文件名和目录，也可以通过使用<code>-print0</code>参数使用空字符(\0)作为分隔符，其主要用途是可以将包含换行符和空格符的文件名传递给<code>xargs</code>命令使用。</p>
<p><code>find base_path -name filename</code>可以通过匹配文件名进行查找，文件名可以使用通配符*</p>
<p><code>find base_path -iname filename</code>在查找时可以忽略大小写</p>
<span id="more"></span>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -maxdepth 限定查找深度</span></span><br><span class="line">find ~ -maxdepth 1 -name <span class="string">&#x27;*RC&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">find ~ maxdepth 1 -iname <span class="string">&#x27;*RC&#x27;</span></span><br><span class="line"><span class="comment"># /home/somebody/.bashrc</span></span><br><span class="line"><span class="comment"># /home/somebody/.zshrc</span></span><br><span class="line"><span class="comment"># /home/somebody/.vimrc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件名使用通配符时因该放入单引号中，shell 会扩展没有使用引号或者使用双引号的通配符</p>
</blockquote>
<p><code>find base_path -name filenameA -a -name filenameB</code>通过逻辑与进行查找</p>
<p><code>find base_path -name filenameA -o -name filenameB</code>通过逻辑或进行查找</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find ~ -maxdepth 1 -name <span class="string">&#x27;*rc&#x27;</span> -a -name <span class="string">&#x27;*zsh*&#x27;</span></span><br><span class="line"><span class="comment"># /home/somebody/.zshrc</span></span><br><span class="line">find ~ -maxdepth 1 -name <span class="string">&#x27;*zsh*&#x27;</span> -o -name <span class="string">&#x27;*bash*&#x27;</span></span><br><span class="line"><span class="comment"># /home/somebody/.zshrc</span></span><br><span class="line"><span class="comment"># /home/somebody/.bashrc</span></span><br><span class="line"><span class="comment"># /home/somebody/.zsh_history</span></span><br><span class="line"><span class="comment"># /home/somebody/.bash_history</span></span><br></pre></td></tr></table></figure>
<p><code>find base_path -path sub_path</code>可以限制查找的路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find ~ -maxdepth 2 -name <span class="built_in">test</span></span><br><span class="line"><span class="comment"># /home/somebody/Documents/test</span></span><br><span class="line"><span class="comment"># /home/somebody/.nvm/test</span></span><br><span class="line">find ~ -maxdepth 2 -path <span class="string">&#x27;*/Documents/*&#x27;</span> -name <span class="built_in">test</span></span><br><span class="line"><span class="comment"># /home/somebody/Documents/test</span></span><br></pre></td></tr></table></figure>
<p><code>find base_path -regex pattern</code>可以使用正则表达式进行精确查找</p>
<p><code>find base_path ! expression</code>可以进行否定查找</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find ~ -maxdepth 2 -name <span class="built_in">test</span></span><br><span class="line"><span class="comment"># /home/somebody/Documents/test</span></span><br><span class="line"><span class="comment"># /home/somebody/.nvm/test</span></span><br><span class="line">find ~ -maxdepth 2 ! -path <span class="string">&#x27;*/Documents/*&#x27;</span> -name <span class="built_in">test</span></span><br><span class="line"><span class="comment"># /home/somebody/.nvm/test</span></span><br></pre></td></tr></table></figure>
<p><code>find base_path -maxdepth number</code>指定最大的查找深度</p>
<p><code>find base_path -mindepth number</code>指定开始查找的最小深度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find ~ -maxdepth 4 -name <span class="built_in">test</span></span><br><span class="line"><span class="comment"># /home/somebody/Documents/test</span></span><br><span class="line"><span class="comment"># /home/somebody/.nvm/test</span></span><br><span class="line"><span class="comment"># /home/somebody/vscode-server/extensions/yzhang.markdown-all-in-one-3.4.0/test</span></span><br><span class="line">find ~ -maxdepth 4 -mindepth 3 -name <span class="built_in">test</span></span><br><span class="line"><span class="comment"># /home/somebody/vscode-server/extensions/yzhang.markdown-all-in-one-3.4.0/test</span></span><br></pre></td></tr></table></figure>
<p><code>find base_path -type filetype</code>指定查找文件类型</p>
<ul>
<li>-type f 普通文件</li>
<li>-type l 符号链接</li>
<li>-type d 目录</li>
<li>-type c 字符设备</li>
<li>-type b 块设备</li>
<li>-type s 套接字</li>
<li>-type p FIFO</li>
</ul>
<p><code>find base_path -atime number</code>按访问时间查找</p>
<p><code>find base_path -mtime number</code>按修改时间查找</p>
<p><code>find base_path -ctime number</code>按变化时间查找</p>
<p>以上时间均以天为单位，可以加上+、-号，表示大于或小于指定天数</p>
<p><code>-amin</code>、<code>-mmin</code>、<code>-cmin</code>则使用分钟进行搜索</p>
<p><code>find base_path -newer file</code>以指定文件做参考，查找比指定文件更新(更近的修改时间)的文件</p>
<p><code>find base_path -size size_number</code>可以按文件大小查找，同样支持使用+、-号指定大于或小于某个大小</p>
<ul>
<li>-size b 块(512 字节)</li>
<li>-size c 字节</li>
<li>-size w 字(2 字节)</li>
<li>-size k 千字节(kb)</li>
<li>-size M 兆字节(Mb)</li>
<li>-size G 吉字节(GB)</li>
</ul>
<p><code>find base_path -perm</code>可以按文件权限查找</p>
<p><code>find base_path -user</code>可以按文件所有权查找</p>
<p><code>find base_path -type f -name filename --delete</code>可以删除匹配的文件</p>
<p><code>find base_path -type f -name filename -exec command</code>可以对匹配文件执行指定操作</p>
<p><code>-exec</code>和<code>printf</code>搭配使用可以生成输出信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find ~ -maxdepth 1 -name <span class="string">&#x27;*rc&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">printf</span> <span class="string">&#x27;RC File: %s\n&#x27;</span> &#123;&#125; \;</span><br><span class="line"><span class="comment"># RC File: /home/somebody/.bashrc</span></span><br><span class="line"><span class="comment"># RC File: /home/somebody/.zshrc</span></span><br><span class="line"><span class="comment"># RC File: /home/somebody/.vimrc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面命令结尾的分号不能省略，否则<code>-exec</code>无法识别要执行什么命令</p>
</blockquote>
<p><code>-prune</code>命令可以实现特定目录或文件的排除，在搜索时排除某些文件或目录的技巧叫做<strong>修剪</strong>，下面例子中，将.git 目录排除，然后打印出所有文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&#x27;.git&#x27;</span> -prune -o -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<h3 id="xargs-命令"><a href="#xargs-命令" class="headerlink" title="xargs 命令"></a>xargs 命令</h3><p>xargs 命令可以从标准输入读取一系列参数，然后使用这些参数来执行指定命令，因此一般情况下 xargs 都紧跟在管道操作符后面。</p>
<p>xargs 默认使用 echo 命令将从 stdin 读取的数据重新输出，并且会把多行数据转换成单行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 4 5 6</span></span><br><span class="line"><span class="comment"># 7 8 9</span></span><br><span class="line">cat <span class="built_in">test</span> | xargs</span><br><span class="line"><span class="comment"># 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>
<p><code>xargs -n number</code>可以限制每次调用命令时用到的参数，可以通过这一特性将单行输入转换成多行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test1</span><br><span class="line"><span class="comment"># 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">cat test1 | xargs -n 3</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 4 5 6</span></span><br><span class="line"><span class="comment"># 7 8 9</span></span><br></pre></td></tr></table></figure>
<p><code>xargs -d delimiter</code>可以指定分隔符。xargs 默认使用空白字符作为分隔符，当遇到文件或是目录名中有空格甚至是换行时，使用默认分隔符来分割输入就会出错：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test2</span><br><span class="line"><span class="comment"># 1 2 3,4 5 6,7 8 9</span></span><br><span class="line">cat test2 | xargs -n 1</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3,4</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 6,7</span></span><br><span class="line"><span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line">cat test2 | xargs -d , -n 1</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 4 5 6</span></span><br><span class="line"><span class="comment"># 7 8 9</span></span><br></pre></td></tr></table></figure>
<p>xargs 命令常常和 find 命令结合使用，执行一些 find 命令的-exec 参数无法做到的复杂操作，但是如果 find 命令的查找结果中包含空白字符时，直接使用管道操作符传递给 xargs 命令会因为默认分隔符的原因出错，这是可以使用 find 命令的<code>-print0</code>参数将查找结果通过 NULL 字符(0)来分隔，然后通过 xargs 命令的<code>-0</code>参数来接受，就可以正确处理包含空格的情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="string">&quot;test 1&quot;</span> <span class="string">&quot;test 2&quot;</span> <span class="string">&quot;test 3&quot;</span></span><br><span class="line"><span class="comment"># test 1</span></span><br><span class="line"><span class="comment"># test 2</span></span><br><span class="line"><span class="comment"># test 3</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment"># &#x27;test 1&#x27; &#x27;test 2&#x27; &#x27;test 3&#x27;</span></span><br><span class="line">find . -name <span class="string">&quot;test *&quot;</span> | xargs cat</span><br><span class="line"><span class="comment"># cat: ./test: No such file or directory</span></span><br><span class="line"><span class="comment"># cat: 2: No such file or directory</span></span><br><span class="line"><span class="comment"># cat: ./test: No such file or directory</span></span><br><span class="line"><span class="comment"># cat: 1: No such file or directory</span></span><br><span class="line"><span class="comment"># cat: ./test: No such file or directory</span></span><br><span class="line"><span class="comment"># cat: 3: No such file or directory</span></span><br><span class="line">find . -name <span class="string">&quot;test *&quot;</span> | xargs -n 1</span><br><span class="line"><span class="comment"># ./test</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># ./test</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># ./test</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">find . -name <span class="string">&quot;test *&quot;</span> -print0 | xargs -0 cat</span><br><span class="line"><span class="comment"># test 1</span></span><br><span class="line"><span class="comment"># test 2</span></span><br><span class="line"><span class="comment"># test 3</span></span><br></pre></td></tr></table></figure>
<p><code>xargs -I &#123;&#125; cmd &#123;&#125;</code>，使用参数<code>-I</code>可以指定替换字符串，这个字符串会在 xargs 命令解析输入时被参数替换掉：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -F</span><br><span class="line"><span class="comment"># &#x27;test 1&#x27; &#x27;test 2&#x27; &#x27;test 3&#x27; test/</span></span><br><span class="line">ls ./<span class="built_in">test</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">find . -name <span class="string">&quot;test *&quot;</span> -print0 | xargs -0 mv ./<span class="built_in">test</span></span><br><span class="line"><span class="comment"># mv: target &#x27;./test 3&#x27; is not a directory</span></span><br><span class="line">find . -name <span class="string">&quot;test *&quot;</span> -print0 | xargs -0 -I &#123;&#125; mv &#123;&#125; ./<span class="built_in">test</span></span><br><span class="line">ls -F</span><br><span class="line"><span class="comment"># test/</span></span><br><span class="line">ls ./<span class="built_in">test</span></span><br><span class="line"><span class="comment"># &#x27;test 1&#x27; &#x27;test 2&#x27; &#x27;test 3&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="tr-命令"><a href="#tr-命令" class="headerlink" title="tr 命令"></a>tr 命令</h3><p>tr 是 translate 的缩写，该命令可以对来自标准输入的内容进行字符替换、字符删除和重复字符压缩。</p>
<p>tr 命令只能通过 stdin(标准输入)接受输入(无法通过命令行参数接受)，其调用格式为：<code>tr [ options ] set1 set2</code>，来自标准输入的字符会按照位置从 set1 映射到 set2(set1 中的第一个字符映射到 set2 中的第一个字符，set1 中的第二个字符映射到 set2 中的第二个字符，以此类推)，然后将输出写入 stdout(标准输出)。set1 和 set2 是字符类或字符组，如果两者长度不相等，那么 set2 会不断复制 set1 的最后一个字符，直到长度与 set1 相等；如果 set2 的长度大于 set1，则 set2 中长度大于 set1 的那一部分字符会被完全忽略。</p>
<p><code>tr &#39;a-zA-Z&#39; &#39;n-za-mN-ZA-M&#39;</code>，这是一个著名加密算法 ROT13 的实现，该替换模式会把字符顺序移动 13 位，文本的加密和解密都是用同一个函数实现：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;some messages here&#x27;</span> | tr <span class="string">&#x27;a-zA-Z&#x27;</span> <span class="string">&#x27;n-za-mN-ZA-M&#x27;</span> &gt; <span class="built_in">test</span></span><br><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># fbzr zrffntrf urer</span></span><br><span class="line">cat <span class="built_in">test</span> | tr <span class="string">&#x27;a-zA-Z&#x27;</span> <span class="string">&#x27;n-za-mN-ZA-M&#x27;</span></span><br><span class="line"><span class="comment"># some messages here</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tr 命令的参数中，需要定义集合时，只需要使用<strong>“起始字符-终止字符”</strong>的方式，如果起始字符到终止字符不是有效的连续字符序列，则该写法被视为包含 3 个元素的集合(<strong>“起始字符、-、终止字符”</strong>)。</p>
</blockquote>
<p><code>tr -d set</code>可以从 stdin 中删除指定集合的字符：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># som0e me3ssa8ges h60er8e</span></span><br><span class="line">cat <span class="built_in">test</span> | tr -d <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line"><span class="comment"># some messages here</span></span><br></pre></td></tr></table></figure>
<p><code>tr -c set1 set2</code>可以将不在集合 set1 中字符替换成 set2 中的字符，<code>tr -d -c set1</code>可以删除所有不在 set1 中的字符：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># som0e me3ssa8ges h60er8e</span></span><br><span class="line">cat <span class="built_in">test</span> | tr -c <span class="string">&#x27;a-zA-Z \n&#x27;</span> <span class="string">&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment"># some messages here</span></span><br><span class="line">cat <span class="built_in">test</span> | tr -d -c <span class="string">&#x27;a-zA-Z \n&#x27;</span></span><br><span class="line"><span class="comment"># some messages here</span></span><br></pre></td></tr></table></figure>
<p><code>tr -s [重复的一组字符]</code>可以删除字符串中重复出现的指定字符：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># some   messages     here</span></span><br><span class="line">cat <span class="built_in">test</span> | tr -s <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="comment"># some messages here</span></span><br><span class="line">cat test1</span><br><span class="line"><span class="comment"># some</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># messages</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># here</span></span><br><span class="line">cat test1 | tr -s <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="comment"># some</span></span><br><span class="line"><span class="comment"># messages</span></span><br><span class="line"><span class="comment"># here</span></span><br></pre></td></tr></table></figure>
<h3 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h3><p>sort 命令可以从特定文件或 stdin 中获取输入，并按指定方式排序后输出到 stdout。</p>
<p><code>sort file1 file2 file3</code>可以对一组文件进行排序</p>
<p><code>sort -n file</code>可以按照数字顺序进行排序</p>
<p><code>sort -r file</code>按照逆序排序</p>
<p><code>sort -M file</code>按照月份排序(一月、二月、三月…)</p>
<p><code>sort -m sorted1 sorted2</code>合并两个已经排序过的文件</p>
<p><code>sort -c file</code>检查文件是否已经排序，如果已经排序则返回为 0 的退出码，否则返回一个非 0 退出码</p>
<p><code>sort -k number file</code>可以按指定列进行排序，如果是单个数字则表示列号，如果是形如<code>1.3,1.4</code>则表示区间范围(第一列第三个字符)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat -n <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 1 some</span></span><br><span class="line"><span class="comment"># 2 messages</span></span><br><span class="line"><span class="comment"># 3 here</span></span><br><span class="line">cat -n <span class="built_in">test</span> | sort -nrk 1</span><br><span class="line"><span class="comment"># 3 here</span></span><br><span class="line"><span class="comment"># 2 messages</span></span><br><span class="line"><span class="comment"># 1 some</span></span><br><span class="line">cat -n <span class="built_in">test</span> | sort -k 2.4,2.5</span><br><span class="line"><span class="comment"># 1 some</span></span><br><span class="line"><span class="comment"># 3 here</span></span><br><span class="line"><span class="comment"># 2 messages</span></span><br></pre></td></tr></table></figure>
<p><code>sort -z</code>，通过-z 参数可以把 sort 的输出传递给 xargs 使用(指定-0)，这样可以避免因为含有空白字符出现错误</p>
<h3 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h3><p>uniq 命令可以从给定文件或 stdin 中读取数据，从中找出唯一的行，报告或删除那些行。uniq 只能作用于排过序的数据，因此通常和 sort 命令搭配使用。</p>
<p><code>sort file | uniq</code>会打印文件内容，但是重复的内容只显示一次</p>
<p><code>sort file | uniq -u</code>只显示文件中唯一的行</p>
<p><code>sort file | uniq -c</code>统计文件中各行出现的次数</p>
<p><code>sort file | uniq -d</code>找出文件中重复的行</p>
<p><code>uniq -s n -w m</code>会跳过每行的前 n 个字符，然后使用最多 m 个字符进行比较：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">test</span></span><br><span class="line"><span class="comment"># u:01:gnu</span></span><br><span class="line"><span class="comment"># d:04:linux</span></span><br><span class="line"><span class="comment"># u:01:bash</span></span><br><span class="line"><span class="comment"># u:01:hack</span></span><br><span class="line">sort <span class="built_in">test</span> | uniq -s 2 -w 2 -c</span><br><span class="line"><span class="comment"># 1 d:04:linux</span></span><br><span class="line"><span class="comment"># 3 u:01:bash</span></span><br><span class="line"><span class="comment"># -s 2跳过每行前两个字符，-w 2以接下来的2个字符进行重复判断，即每行中的2位数字，-c统计重复次数</span></span><br><span class="line"><span class="comment"># 虽然同为u:01:开头的3行内容并不相同，但是这里指定了以每行中的2位数字进行判断，所以统计为u:01:出现了3次</span></span><br></pre></td></tr></table></figure>
<p><code>uniq -z</code>，通过-z 参数，可以将 uniq 的输出传递给 xargs 使用(指定-0)，这样可以避免因为空白字符出现错误</p>
<h3 id="mktemp-命令"><a href="#mktemp-命令" class="headerlink" title="mktemp 命令"></a>mktemp 命令</h3><p><code>filename=$(mkdtemp)</code>可以创建临时文件，并将文件名存入变量</p>
<p><code>dirname=$(mktemp -d)</code>可以创建临时目录，并将目录名存入变量</p>
<p><code>mktemp -u</code>只生成临时文件名，但不创建实际文件或目录</p>
<h3 id="、-、-和-操作符"><a href="#、-、-和-操作符" class="headerlink" title="%、%%、#和##操作符"></a>%、%%、#和##操作符</h3><p><code>$&#123;VAR%.*&#125;</code>从字符串中删除位于%右侧的通配符所匹配的所有字符，通配符从右向左匹配。%属于非贪婪(non-greedy)操作，而%%属于贪婪匹配：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file_jpg=<span class="string">&#x27;sample.jpg&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file_jpg%.*&#125;</span></span><br><span class="line"><span class="comment"># sample</span></span><br><span class="line">filename=<span class="string">&#x27;back.fun.book.txt&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename%.*&#125;</span></span><br><span class="line"><span class="comment"># back.fun.book</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename%%.*&#125;</span></span><br><span class="line"><span class="comment"># back</span></span><br></pre></td></tr></table></figure>
<p><code>$&#123;VAR#*.&#125;</code>和%效果相反，只不过会删除位于#左边通配符匹配到的所有字符，匹配方向为从左向右，同样的，#为非贪婪匹配，##为贪婪匹配。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$file_jpg</span></span><br><span class="line"><span class="comment"># sample.jpg</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;file_jpg#*.&#125;</span></span><br><span class="line"><span class="comment"># jpg</span></span><br><span class="line"><span class="built_in">echo</span> filename</span><br><span class="line"><span class="comment"># back.fun.book.txt</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename#*.&#125;</span></span><br><span class="line"><span class="comment"># fun.book.txt</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename##*.&#125;</span></span><br><span class="line"><span class="comment"># txt</span></span><br></pre></td></tr></table></figure>
<p>%、%%、#、##常用来分隔文件名和文件扩展名，也可以用来分隔 URL 地址获取协议、域名、主机名等等。</p>
<blockquote>
<p>考虑到文件名中可能含有多个.，因此提取文件扩展名时更多的是使用##进行贪婪匹配</p>
</blockquote>
<p>批量重命名文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="comment"># back.jpg fun.png book.jpg</span></span><br><span class="line">cat rename.sh</span><br><span class="line"><span class="comment"># count=1</span></span><br><span class="line"><span class="comment"># for img in `find . -maxdepth 1 -type f -iname &#x27;*.jpg&#x27; -o -iname &#x27;*.png&#x27;`</span></span><br><span class="line"><span class="comment"># do</span></span><br><span class="line"><span class="comment">#     new=IMG-$count.$&#123;img##*.&#125;</span></span><br><span class="line"><span class="comment">#     echo &quot;Rename $img to $new&quot;</span></span><br><span class="line"><span class="comment">#     mv $img $new</span></span><br><span class="line"><span class="comment">#     let count++</span></span><br><span class="line"><span class="comment"># done</span></span><br><span class="line">. ./rename.sh</span><br><span class="line">ls</span><br><span class="line"><span class="comment"># IMG-1.png IMG-2.jpg IMG-3.jpg</span></span><br></pre></td></tr></table></figure>
<h3 id="parallel-命令"><a href="#parallel-命令" class="headerlink" title="parallel 命令"></a>parallel 命令</h3><p>parallel 命令从 stdin 中读取文件列表，用类似 find 的-exec 或者 xargs 的方式来使用指定命令处理文件，其中{}替代要处理的文件名，{.}替代无扩展名的文件名。parallel 命令可以优化系统资源使用，在同时处理大量文件时，可以避免系统过载。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="comment"># test1.txt test2.txt test3.txt</span></span><br><span class="line">cat test1.txt test2.txt test3.txt</span><br><span class="line"><span class="comment"># test 1</span></span><br><span class="line"><span class="comment"># test 2</span></span><br><span class="line"><span class="comment"># test 3</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&#x27;test*&#x27;</span> | parallel cat &#123;&#125;</span><br><span class="line"><span class="comment"># test 1</span></span><br><span class="line"><span class="comment"># test 2</span></span><br><span class="line"><span class="comment"># test 3</span></span><br><span class="line">find -<span class="built_in">type</span> f -name <span class="string">&#x27;test*&#x27;</span> | parallel mv &#123;&#125; &#123;.&#125;New.txt</span><br><span class="line">ls</span><br><span class="line"><span class="comment"># test1New.txt test2New.txt test3New.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="dd-命令"><a href="#dd-命令" class="headerlink" title="dd 命令"></a>dd 命令</h3><p>dd 命令会克隆给定的输入内容，然后将一模一样的一份副本写入输出。stdin、设备文件、输入文件等都可以作为输入，stdout、设备文件、普通文件等也可以作为输出。</p>
<p><code>dd if=/dev/zero of=file bs=1M count=1</code>会生成一个内容为空的 1M 大小的文件。其中，if 代表输入(input file)，/dev/zero 是一个特殊的字符设备，会返回 0 值字节(\0)；of 代表输入(output file)，bs 代表以字节为单位的块大小(block size)，count 代表需要被复制的块数量。如果将命令中的 bs 改为 2M，count 改为 2，则会生成一个内容为空的 4M 大小的文件。如果省略 if 则会从 stdin 读取输入，而省略 of 则会将结果输出到 stdout。</p>
<p>bs 支持的单位如下：</p>
<ul>
<li>c 字节(B)</li>
<li>w 字(2B)</li>
<li>B 块(512B)</li>
<li>K 千字节(1024B)</li>
<li>M 兆字节(1024KB)</li>
<li>G 吉字节(1024MB)</li>
</ul>
<h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><p><code>chmod u=rwx g=rwx o=rwx filename</code>使用 u(User)、g(Group)和 o(Other)分别为用户、用户组和其他用户设置权限</p>
<p><code>chmod a+x</code>为所有用户添加执行权限</p>
<p><code>chmod a-x</code>为所有用户删除执行权限</p>
<p><code>chmod 777</code>为所有用户设置读写执行权限(r=4 w=2 x=1)</p>
<p><code>chmod 777 . -R</code>对当前目录递归的设置读写执行权限</p>
<h3 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h3><p><code>chown user:group filename</code>修改文件所属用户和用户组</p>
<p><code>chown user:group . -R</code>对当前目录递归的设置用户和用户组</p>
<h3 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h3><p><code>touch filename</code>可以生成空白文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> &#123;1...100&#125;.txt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  touch <span class="variable">$name</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>批量生成名字为 1.txt 到 100.txt 的空白文件。如果文件不存在则会新创建文件，如果文件已经存在，则会将文件的所有时间戳更新为当前时间。可以通过参数<code>-a</code>只更新访问时间、参数<code>-m</code>只更新修改时间、参数<code>-d</code>可以将时间戳修改为指定时间而不是当前时间。</p>
<h3 id="ln-s-命令"><a href="#ln-s-命令" class="headerlink" title="ln -s 命令"></a>ln -s 命令</h3><p>ln -s 命令用来创建符号链接，类似 windows 的快捷方式，格式为：</p>
<p><code>ln -s target symbolic_link_name</code></p>
<h3 id="环回文件"><a href="#环回文件" class="headerlink" title="环回文件"></a>环回文件</h3><p>Linux 文件系统通常位于磁盘或 U 盘上，但其实文件也可以作为文件系统进行挂在，这种存在于文件中的文件系统可用于测试、文件系统定制或者作为机密信息的加密盘。</p>
<p>下面在一个大小为 1GB 的文件中创建 ext4 文件系统并进行挂在：</p>
<ol>
<li><p>使用 dd 命令创建一个 1GB 大小的文件</p>
<p><code>dd if=/dev/zero of=loopbackfile.img bs=1G count=1</code></p>
</li>
<li><p>用 mkfs 命令将 1GB 的文件格式化为 ext4 文件系统</p>
<p><code>mkfs.ext4 loopbackfile.img</code></p>
</li>
<li><p>使用 file 命令检查文件系统</p>
<p><code>file loopbackfile.img</code></p>
</li>
<li><p>使用 mkdir 创建挂载点并挂载环回文件</p>
<p><code>mkdir /mnt/loopback &amp;&amp; mount -o loop loopbackfile.img /mnt/loopback</code></p>
<p>选项<code>-o loop</code>用来指定挂载环回文件</p>
</li>
<li><p>使用下面的方式卸载</p>
<p><code>umount /mnt/loopback</code></p>
</li>
</ol>
<h3 id="diff-命令"><a href="#diff-命令" class="headerlink" title="diff 命令"></a>diff 命令</h3><p>diff 命令可以用来比较两个文件之间的差异，也可以利用修补文件(patch file)将两个文件同步。</p>
<p><code>diff -u version1 version2</code>显示两个文件之间的差异，选项<code>-u</code>指定输出为一体化显示，更易于阅读。</p>
<p><code>diff -u version1 version2 &gt; version.patch</code>生成修补文件</p>
<p><code>patch -p1 version1 &lt; version.patch</code>使用修补文件修补 version1 使 version1 与 version2 文件一致，修补之后再次使用同样的方式进行修补则会撤销之前的修补。</p>
<p><code>patch -p2 version2 &lt; version.patch</code>则使用修补文件修补 version2 使 version2 与 version1 文件一致，再次使用同样的方式修补则会撤销之前的修补。</p>
<h3 id="head-和-tail-命令"><a href="#head-和-tail-命令" class="headerlink" title="head 和 tail 命令"></a>head 和 tail 命令</h3><p><code>head file</code>读取文件前 10 行进行显示，参数<code>-n</code>可以指定要显示的行数，如果行数是一个负数，则打印除指定行以前的所有行</p>
<p><code>tail file</code>读取文件的最后 10 行进行显示，参数<code>-n</code>可以指定要显示的行数，如果行数指定为形如<code>+M</code>的模式，则显示除 M-1 行(从第 M 行到结尾)的所有行。</p>
<p><code>tail -f file</code>会监视文件的增长并将更新内容显示出来，该用法常常用于跟踪日志文件。</p>
<h3 id="pushd-和-popd-命令"><a href="#pushd-和-popd-命令" class="headerlink" title="pushd 和 popd 命令"></a>pushd 和 popd 命令</h3><p>pushd 和 popd 可以用来替代 cd 命令，这对命令用于在多个目录之间切换而无需重新输入目录路径，这两条命令会创建一个路径栈，该路径栈是一个保存了已访问目录的 LIFO(Last In First Out，后进先出)列表。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dirs</span>  <span class="comment"># 显示已访问目录路径栈内容</span></span><br><span class="line"><span class="comment"># ~</span></span><br><span class="line"><span class="built_in">pushd</span> ./Documents  <span class="comment"># 压入并切换路径</span></span><br><span class="line"><span class="built_in">dirs</span></span><br><span class="line"><span class="comment"># ~/Documents ~</span></span><br><span class="line"><span class="built_in">pushd</span> ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">dirs</span></span><br><span class="line"><span class="comment"># ~/Documents/test ~/Documents ~</span></span><br><span class="line"><span class="built_in">pushd</span> +0  <span class="comment"># 切换目录并更新已访问目录路径栈</span></span><br><span class="line"><span class="built_in">dirs</span></span><br><span class="line"><span class="comment"># ~ ~/Documents/test ~/Documents</span></span><br><span class="line"><span class="comment"># pushd总是向路径栈中压入目录</span></span><br><span class="line"><span class="built_in">popd</span>  <span class="comment"># 删除最近压入的路径并切换到下一个目录</span></span><br><span class="line"><span class="built_in">dirs</span></span><br><span class="line"><span class="comment"># ~/Documents/test ~/Documents</span></span><br><span class="line"><span class="built_in">popd</span> +0  <span class="comment"># 删除路径栈中特定的路径</span></span><br><span class="line"><span class="built_in">dirs</span></span><br><span class="line"><span class="comment"># ~/Documents/test</span></span><br></pre></td></tr></table></figure>
<h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><p><code>wc -l file</code>统计文件中的行数</p>
<p><code>wc -w file</code>统计单词数</p>
<p><code>wc -c file</code>统计字符数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234&#x27;</span> | wc -c</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;1234&#x27;</span> | wc -c</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># echo默认添加换行符，-n参数指定不添加</span></span><br></pre></td></tr></table></figure>
<p><code>wc file</code>不指定参数时，会同时打印出行数、单词书和字符数</p>
<p><code>wc -L file</code>打印出文件中最长一行的长度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;1\n12\n123\n1234\n12345&#x27;</span> | wc</span><br><span class="line"><span class="comment"># 5 5 20</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;1\n12\n123\n1234\n12345&#x27;</span> | wc -L</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h3 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a>tree 命令</h3><p>tree 命令可以用图形化树状结构打印出文件和目录。</p>
<p><code>tree path -P PATTERN</code>可以只显示匹配指定模式的文件</p>
<p><code>tree path -I PATTERN</code>可以只显示不匹配指定模式的文件</p>
<p><code>tree -h</code>可以同时打印出文件和目录的大小</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Flask实现简单的用户注册登录功能</title>
    <url>/2021/07/21/%E4%BD%BF%E7%94%A8Flask%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>&emsp;&emsp;Flask 是 Python 世界中非常流行的 Web 框架之一，其以轻量和上手简单著称，被称作微框架(microframework)，它可以很好的结合 MVC 模式，通过丰富的插件库根据自身需求进行定制化，在短时间内就能完成一个功能丰富的中小型 Web 服务开发。</p>
<p>&emsp;&emsp;本文中我们将尝试使用 Flask 来实现简单的用户注册登录功能，涉及到构建蓝图、使用 jinja2 模板引擎渲染前端页面、使用 SQLAlchemy 操作 MySQL 数据库、使用 WTForms 验证用户提交的表单信息、使用 Cookie 保存用户登录状态、设置路由守卫对页面进行访问控制，最后使用自定义函数装饰器和 Python 标准库中的 contextmanager 上下文管理器，优化数据库操作，增加设置默认查询条件功能和操作失败自动回滚功能。通过这样一个简单的项目，能够对使用 Flask 进行 Web 开发的流程有一个初步的认识，并且熟悉一些开发中常用的 Flask 第三方插件，提升代码质量、加快开发速度，避免重复造轮子。</p>
<h2 id="搭建项目结构"><a href="#搭建项目结构" class="headerlink" title="搭建项目结构"></a>搭建项目结构</h2><p>&emsp;&emsp;如下图所示：</p>
<img src="/2021/07/21/%E4%BD%BF%E7%94%A8Flask%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/skeleton.jpeg" class="" title="project skeleton">
<p>&emsp;&emsp;根目录下的 app.py 作为入口文件启动项目，app 是整个项目的开发目录，app/config 是配置文件目录、app/forms 是表单校验文件目录、app/lib 是自定义工具类文件目录、app/manager 是路由蓝图文件目录、app/models 是数据库文件目录、app/static 是静态文件目录、app/templates 是模板文件目录。</p>
<p>&emsp;&emsp;项目根目录下的 Pipfile 和 Pipefile.lock 是使用 pipenv 构建虚拟开发环境产生的配置文件。</p>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>&emsp;&emsp;要使用 Flask 启动一个 Web 服务非常简单：创建一个 Flask 实例，传入自定义配置或者直接使用默认配置，定义一个路由绑定视图函数，调用实例的 run 方法。</p>
<p>&emsp;&emsp;首先在 app/<strong>init</strong>.py 中创建实例并进行配置：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">    app=Flask(__name__)</span><br><span class="line">    app.config.from_pyfile(<span class="string">&quot;config/setting.py&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后在项目入口文件 app.py 中导入 Flask 实例并启动服务：</p>
<figure class="highlight python"><figcaption><span>app.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">app=create_app()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main&quot;</span>:</span><br><span class="line">app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里调用 run 方法时传入参数<code>host=&quot;0.0.0.0&quot;</code>是为了可以在开发时通过局域网内的设备进行访问。</p>
<p>&emsp;&emsp;对于配置文件来说，到目前只需要配置开启 debug 模式，方便开发中发生错误时查看详细异常信息。</p>
<figure class="highlight python"><figcaption><span>app/config/setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DEBUG=<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，运行入口文件启动服务：</p>
<blockquote>
<p>$ python ./app.py</p>
</blockquote>
<p>&emsp;&emsp;浏览器访问 localhost:5000 就可以看到项目首页。</p>
<span id="more"></span>
<h2 id="路由和蓝图"><a href="#路由和蓝图" class="headerlink" title="路由和蓝图"></a>路由和蓝图</h2><p>&emsp;&emsp;蓝图(blueprint)是一个模块化处理的类，它将单个应用的视图、模板和静态文件进行结合，可以看作是一个存储和操作路由映射方法的容器，主要用来实现客户端请求和 URL 相互关联的功能。</p>
<p>&emsp;&emsp;下面我们将之前注册的首页路由以蓝图的方式来实现。</p>
<p>&emsp;&emsp;在项目根目录下的 manager 目录用于统一存放蓝图文件，首先创建一个名为 web 的蓝图：</p>
<figure class="highlight python"><figcaption><span>app/manager/blueprint.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">web=Blueprint(<span class="string">&quot;web&quot;</span>,__name__,url_prefix=<span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后使用新创建的蓝图来注册首页路由：</p>
<figure class="highlight python"><figcaption><span>app/manager/web.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .blueprint <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="meta">@web.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在 app/manager/<strong>init</strong>.py 中引入该目录下的 web.py，这样之后导入 app/manager 时会自动应用 web.py 中注册的路由：</p>
<figure class="highlight python"><figcaption><span>app/manager/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> web</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，在应用中注册新创建的蓝图：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_blueprint</span>(<span class="params">app</span>):</span></span><br><span class="line">  <span class="keyword">from</span> .manager.blueprint <span class="keyword">import</span> web</span><br><span class="line">  app.register_blueprint(web)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">  app=Flask(__name__)</span><br><span class="line">  app.config.from_pyfile(<span class="string">&quot;config/setting.py&quot;</span>)</span><br><span class="line">  register_blueprint(app)</span><br><span class="line">  <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>&emsp;&emsp;在 Python 世界中，连接关系型数据库常用 SQLAlchemy，其秉持 Code First 的思想，以 ORM(对象关系映射)的方式操作数据库，大大降低了开发难度。在 Flask 的插件库中同样有对应的插件 Flask-SQLAlchemy，该插件对原生的 SQLAlchemy 进行了封装，方便和 Flask 结合使用。</p>
<h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><p>&emsp;&emsp;首先对数据库进行配置：</p>
<figure class="highlight python"><figcaption><span>app/config/setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DEBUG=<span class="literal">True</span></span><br><span class="line">SECRET_KEY=<span class="string">&quot;!@#$%^&amp;*&quot;</span></span><br><span class="line">SQLALCHEMY_DATABASE_URI=<span class="string">&quot;mysql+pymysql://root:123456@localhost:3306/flask&quot;</span></span><br><span class="line">SQLALCHEMY_ECHO=<span class="literal">True</span></span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATION=<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;配置项都比较简单易懂，具体说明可以自行网上查看。</p>
<p>&emsp;&emsp;接下来进行数据表的定义，在 app/models 目录中统一存放数据库操作相关文件，首先创建一个基类，用于定义后面将要实现的用户表中的用户注册时间字段以及激活/冻结状态字段。</p>
<figure class="highlight python"><figcaption><span>app/models/base.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column,Integer,SmallInteger</span><br><span class="line"></span><br><span class="line">db=SQLAlchemy()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">  __abstract__=<span class="literal">True</span></span><br><span class="line">  status=Column(SmallInteger,default=<span class="number">1</span>)</span><br><span class="line">  create_time=Column(<span class="string">&quot;create_time&quot;</span>,Integer,nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.create_time=<span class="built_in">int</span>(datetime.now().timestamp())</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里在 Base 类中设置<code>__abstract__=True</code>是因为这只是定义一个基类，不需要在数据库中对应生成一个表，如果不设置<code>__abstract__=True</code>，则 SQLAlchemy 会因为 Base 类中没有指定主键而报错。</p>
<p>&emsp;&emsp;接下来实现用户表：</p>
<figure class="highlight python"><figcaption><span>app/models/user.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column,Integer,String</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .base <span class="keyword">import</span> Base</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">  <span class="built_in">id</span>=Column(Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">  nickname=Column(String(<span class="number">20</span>),nullable=<span class="literal">False</span>)</span><br><span class="line">  email=Column(String(<span class="number">50</span>),nullable=<span class="literal">False</span>,unique=<span class="literal">True</span>)</span><br><span class="line">  phone_number=Column(<span class="string">&quot;phone_number&quot;</span>,String(<span class="number">11</span>),nullable=<span class="literal">False</span>,unique=<span class="literal">True</span>)</span><br><span class="line">  password=Column(String(<span class="number">32</span>),nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，在应用中初始化 ORM 模型并且创建数据表：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_blueprint</span>(<span class="params">app</span>):</span></span><br><span class="line">  <span class="keyword">from</span> .manager.blueprint <span class="keyword">import</span> web</span><br><span class="line">  app.register_blueprint(web)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_db</span>(<span class="params">app</span>):</span></span><br><span class="line">  <span class="keyword">from</span> .models.base <span class="keyword">import</span> db</span><br><span class="line">  db.init_app(app)</span><br><span class="line">  db.create_all(app=app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">  app=Flask(__name__)</span><br><span class="line">  app.config.from_pyfile(<span class="string">&quot;config/setting.py&quot;</span>)</span><br><span class="line">  register_blueprint(app)</span><br><span class="line">  create_db(app)</span><br><span class="line">  <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>
<h3 id="对用户密码进行加密"><a href="#对用户密码进行加密" class="headerlink" title="对用户密码进行加密"></a>对用户密码进行加密</h3><p>&emsp;&emsp;让我们在回过头看看用户表的定义，其中有几个问题，首先，用户密码任何时候都不能以明文存储，这一点可以利用 Flask 使用的 WSGI 工具包——werkzeug 来解决：</p>
<figure class="highlight python"><figcaption><span>app/models/user.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column,Integer,String</span><br><span class="line"><span class="keyword">from</span> werkzeug.security <span class="keyword">import</span> check_password_hash,generate_password_hash</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .base <span class="keyword">import</span> Base</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">  <span class="built_in">id</span>=Column(Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">  nickname=Column(String(<span class="number">20</span>),nullable=<span class="literal">False</span>)</span><br><span class="line">  email=Column(String(<span class="number">50</span>),nullable=<span class="literal">False</span>,unique=<span class="literal">True</span>)</span><br><span class="line">  phone_number=Column(<span class="string">&quot;phone_number&quot;</span>,String(<span class="number">11</span>),nullable=<span class="literal">False</span>,unique=<span class="literal">True</span>)</span><br><span class="line">  _password=Column(<span class="string">&quot;password&quot;</span>,String(<span class="number">128</span>),nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">password</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self._password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">  @password.setter</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">password</span>(<span class="params">self,raw</span>):</span></span><br><span class="line">    self._password=generate_password_hash(raw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_password</span>(<span class="params">self,raw</span>):</span></span><br><span class="line">    <span class="keyword">return</span> check_password_hash(self.password,raw)</span><br></pre></td></tr></table></figure>
<h3 id="设置默认查表条件"><a href="#设置默认查表条件" class="headerlink" title="设置默认查表条件"></a>设置默认查表条件</h3><p>&emsp;&emsp;在实际应用中，用户注册或删除一般采用软删除的方式，及设置标志位，这里我们在 Base 类中使用<code>status</code>来表示，默认值 1 表示用户为激活状态，设为 0 则表示用户被冻结。因此，当我们查询用户表时，始终都应该指定<code>status=1</code>为查询条件，如果总是在执行查询命令时手动指定，无疑使代码非常冗余，因此我们需要实现一个指定默认查询条件的功能。</p>
<p>&emsp;&emsp;在 app/lib 目录下创建一些自定义工具类：</p>
<figure class="highlight python"><figcaption><span>app/lib/helper.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_query_conditions</span>(<span class="params">**conditions</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">      <span class="keyword">for</span> k,v <span class="keyword">in</span> conditions.items():</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> kwargs.keys():</span><br><span class="line">          kwargs[k]=v</span><br><span class="line">      <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">  <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>set_query_conditions</code>是一个自定义函数装饰器，接下来对 app/models/base 中 Base 类所继承的 db.Model 进行改在，利用我们的自定义函数装饰器为数据库查询方法<code>filter_by</code>指定默认条件：</p>
<figure class="highlight python"><figcaption><span>app/models/base.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> BaseQuery,SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column,Integer,SmallInteger</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..lib.helper <span class="keyword">import</span> set_query_conditions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomQuery</span>(<span class="params">BaseQuery</span>):</span></span><br><span class="line"><span class="meta">  @set_query_conditions(<span class="params">status=<span class="number">1</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter_by</span>(<span class="params">self,**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().filter_by(**kwargs)</span><br><span class="line"></span><br><span class="line">db=SQLAlchemy(query_class=CustomQuery)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">  __abstract__=<span class="literal">True</span></span><br><span class="line">  status=Column(SmallInteger,default=<span class="number">1</span>)</span><br><span class="line">  create_time=Column(<span class="string">&quot;create_time&quot;</span>,Integer,nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.create_time=<span class="built_in">int</span>(datetime.now().timestamp())</span><br></pre></td></tr></table></figure>
<h3 id="操作失败自动回滚"><a href="#操作失败自动回滚" class="headerlink" title="操作失败自动回滚"></a>操作失败自动回滚</h3><p>&emsp;&emsp;最后，我们还可以对数据库操作进一步优化，添加上自动回滚功能，这里可以通过 Python 标准库 contextlib 中的 contextmanager 来实现，其原理是使用了上下文管理器，在进入和离开上下文环境时，执行指定的操作，具体细节可以上网查看：</p>
<figure class="highlight python"><figcaption><span>app/models/base.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> BaseQuery,SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column,Integer,SmallInteger</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..lib.helper <span class="keyword">import</span> set_query_conditions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomQuery</span>(<span class="params">BaseQuery</span>):</span></span><br><span class="line"><span class="meta">  @set_query_conditions(<span class="params">status=<span class="number">1</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter_by</span>(<span class="params">self,**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().filter_by(**kwargs)</span><br><span class="line"></span><br><span class="line">db=SQLAlchemy(query_class=CustomQuery)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">  __abstract__=<span class="literal">True</span></span><br><span class="line">  status=Column(SmallInteger,default=<span class="number">1</span>)</span><br><span class="line">  create_time=Column(<span class="string">&quot;create_time&quot;</span>,Integer,nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.create_time=<span class="built_in">int</span>(datetime.now().timestamp())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line"><span class="meta">  @contextmanager</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">auto_commit</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">      db.session.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">      db.session.rollback()</span><br><span class="line">      <span class="keyword">raise</span> e</span><br></pre></td></tr></table></figure>
<h2 id="校验表单数据"><a href="#校验表单数据" class="headerlink" title="校验表单数据"></a>校验表单数据</h2><p>&emsp;&emsp;Flask 内部并没有提供全面的表单验证功能，所以需要借助一些第三方插件来实现，这里采用了 WTForms。WTForms 是一个支持多种 Web 框架的 Form 插件，主要用于对用户请求数据进行校验，而 Flask 插件库中也有对应版本——Flask-WTForms。</p>
<p>&emsp;&emsp;在 app/forms 目录下新建 auth.py 用来统一编写表单校验类：</p>
<figure class="highlight python"><figcaption><span>app/forms/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> PasswordField,StringField,ValidationError</span><br><span class="line"><span class="keyword">from</span> wtforms.fields.html5 <span class="keyword">import</span> EmailField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired,Length,Email,Regexp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..models.user <span class="keyword">import</span> User</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意，这里用到的邮箱验证器可能需要单独安装 email-validator 包，可以自行视情况进行安装。</p>
<p>&emsp;&emsp;接上文，在 app/forms/auth.py 中定义表单验证类，其中除了使用 WTForms 提供的标准验证器外，还使用了自定义验证器，方式是以 <code>validate_[字段名称](self,field)</code>为名定义实例方法，WTForms 会将其自动应用到对应的字段上，而验证失败则需要抛出 WTForms 的 ValidationError 类的实例：</p>
<figure class="highlight python"><figcaption><span>app/forms/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    nickname = StringField(validators=[DataRequired(),</span><br><span class="line">                                       Length(<span class="built_in">min</span>=<span class="number">4</span>, <span class="built_in">max</span>=<span class="number">20</span>),</span><br><span class="line">                                       Regexp(<span class="string">r&quot;^\w&#123;4,20&#125;$&quot;</span>, flags=<span class="number">0</span>, message=<span class="string">u&quot;用户昵称最少4位最多20位字符，并且不能使用特殊字符！&quot;</span>)])</span><br><span class="line">    email = EmailField(validators=[DataRequired(),</span><br><span class="line">                                   Length(<span class="built_in">min</span>=<span class="number">6</span>, <span class="built_in">max</span>=<span class="number">50</span>)])</span><br><span class="line">    phone_number = StringField(validators=[DataRequired(),</span><br><span class="line">                                           Length(<span class="built_in">min</span>=<span class="number">11</span>, <span class="built_in">max</span>=<span class="number">11</span>),</span><br><span class="line">                                           Regexp(<span class="string">r&quot;^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d&#123;8&#125;$&quot;</span>, flags=<span class="number">0</span>, message=<span class="string">u&quot;无效的手机号码&quot;</span>)])</span><br><span class="line">    password = PasswordField(validators=[DataRequired(),</span><br><span class="line">                                         Length(<span class="built_in">min</span>=<span class="number">6</span>, <span class="built_in">max</span>=<span class="number">32</span>),</span><br><span class="line">                                         Regexp(<span class="string">r&quot;^\w&#123;6,32&#125;$&quot;</span>, flags=<span class="number">0</span>, message=<span class="string">u&quot;密码最少6位最多32位字符，并且不能使用特殊字符&quot;</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_email</span>(<span class="params">self, field</span>):</span></span><br><span class="line">        <span class="keyword">if</span> User.query.filter_by(email=field.data).first():</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">u&quot;该邮箱已被注册！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_phone_number</span>(<span class="params">self, field</span>):</span></span><br><span class="line">        <span class="keyword">if</span> User.query.filter_by(phone_number=field.data):</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">u&quot;该手机号码已被注册！&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="用户注册接口与页面"><a href="#用户注册接口与页面" class="headerlink" title="用户注册接口与页面"></a>用户注册接口与页面</h2><h3 id="路由和视图函数"><a href="#路由和视图函数" class="headerlink" title="路由和视图函数"></a>路由和视图函数</h3><p>&emsp;&emsp;首先新建一个蓝图管理与用户操作相关的路由：</p>
<figure class="highlight python"><figcaption><span>app/manager/blueprint.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">web=Blueprint(<span class="string">&quot;web&quot;</span>,__name__,url_prefix=<span class="string">&quot;/&quot;</span>)</span><br><span class="line">auth=Blueprint(<span class="string">&quot;auth&quot;</span>,__name__,url_prefix=<span class="string">&quot;/user&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;新建一个文件统一管理用户路由相关的视图函数：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> flash,redirect,render_template,url_for,request</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..forms.auth <span class="keyword">import</span> UserForm</span><br><span class="line"><span class="keyword">from</span> ..models.base <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> ..models.user <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> .blueprint <span class="keyword">import</span> auth</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.route(<span class="params"><span class="string">&quot;/register&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">  form=UserForm()</span><br><span class="line">  <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Register Page&lt;/h1&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里通过 flask-wtforms 提供的 validate_on_submit 方法，在得到客户端通过 POST 请求提交表单内容并且通过表单数据校验后，做进一步处理，而通过 GET 请求访问路由时则返回 html。这里暂时先返回一个页面标题，后面会使用 jinja2 模板引擎渲染 html 页面进行返回。</p>
<p>&emsp;&emsp;接下来完成用户注册逻辑：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文if语句块</span></span><br><span class="line"><span class="comment"># if form.validate_on_submit():</span></span><br><span class="line">  nickname=form.data.get(<span class="string">&quot;nickname&quot;</span>)</span><br><span class="line">  email=form.data.get(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">  phone_number=form.data.get(<span class="string">&quot;phone_number&quot;</span>)</span><br><span class="line">  password=form.data.get(<span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先通过前面定义的 UserForm 类的实例来获得用户提交的表单数据，这里所获得的数据都是通过 wtforms 校验后的正确数据，而校验失败的信息会被放入 form.errors 中，后面会在通过模板引擎渲染 html 页面时通过条件判断，在页面中显示校验失败的错误信息。</p>
<p>&emsp;&emsp;下面新建一条用户记录并写入数据库：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line">  user=User()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里实例化一个 user 后需要添加用户属性，因此在 Base 类中增加一个添加用户属性的方法：</p>
<figure class="highlight python"><figcaption><span>app/models/base.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Base类中添加add_attrs方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_attrs</span>(<span class="params">self,**attrs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> attrs.items():</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">hasattr</span>(self,k) <span class="keyword">and</span> k!=<span class="string">&quot;id&quot;</span>:  <span class="comment"># 不能指定主键</span></span><br><span class="line">        <span class="built_in">setattr</span>(self,k,v)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;回到用户注册视图函数中继续编写：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line">  user.add_attrs(nickname=nickname,</span><br><span class="line">                 email=email,</span><br><span class="line">                 phone_number=phone_number,</span><br><span class="line">                 password=password)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> User.auto_commit():</span><br><span class="line">      db.session.add(user)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;auth.login&quot;</span>))</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> _:</span><br><span class="line">    flash(<span class="string">u&quot;注册失败！&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当成功注册以后，跳转到登录试图，否侧提示注册失败，这里所使用的 flash 是 Flask 提供的消息闪现方法，可以在渲染 html 页面时取得该方法传递的信息在页面中进行展示，后面在使用模板引擎编写 html 页面时会用到。</p>
<p>&emsp;&emsp;注意这里在想数据库写入数据时，通过 with…as 语句调用了前面自定义的方法：auto_commit(由于该方法并没有返回值，所以省略了 as 关键字)，该方法通过 python 的上下文管理器来实现数据库操作失败自动回滚，并抛出错误。</p>
<p>&emsp;&emsp;下面在应用中注册蓝图，引入路由：</p>
<figure class="highlight python"><figcaption><span>app/manager/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> auth,web</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># register_blueprint函数定义内</span></span><br><span class="line"><span class="comment"># def register_blueprint(app):</span></span><br><span class="line">  <span class="keyword">from</span> .manager.blueprint <span class="keyword">import</span> auth,web</span><br><span class="line">  app.register_blueprint(auth)</span><br><span class="line">  app.register_blueprint(web)</span><br></pre></td></tr></table></figure>
<h3 id="模板引擎与注册页面"><a href="#模板引擎与注册页面" class="headerlink" title="模板引擎与注册页面"></a>模板引擎与注册页面</h3><p>&emsp;&emsp;下面使用 jinja2 模板引擎编写 html 页面。所有模板文件统一放置与 app/templates 目录下进行管理，这也是 Flask 默认的模板文件查找目录。jinja2 支持变量、条件、循环、继承等特性，具体使用方法可以上网查看。</p>
<p>&emsp;&emsp;首先创建一个基础模板统一页面布局：</p>
<figure class="highlight html"><figcaption><span>app/templates/layout.html</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../static/bootstrap-icons.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../static/bootstrap.min.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Flask Learn<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;bg-dark text-light&quot;</span>&gt;</span></span><br><span class="line">    &#123;% block header %&#125; Here is the header area! &#123;% endblock %&#125; &#123;% block aside %&#125;</span><br><span class="line">    Here is the aside area! &#123;% endblock %&#125; &#123;% block main %&#125; Here is the main</span><br><span class="line">    area! &#123;% endblock %&#125; &#123;% block footer %&#125; Here is the footer area! &#123;%</span><br><span class="line">    endblock%&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../static/bootstrap.bundle.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后编写头部导航、侧栏提示信息以及页脚：</p>
<figure class="highlight html"><figcaption><span>app/templates/base.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;layout.html&quot; %&#125; &#123;% block header %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid header&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-expand-sm navbar-dark bg-dark&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>Flask Learn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;navbar-toggler&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-bs-toggle</span>=<span class="string">&quot;collapse&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-bs-target</span>=<span class="string">&quot;#navbarNav&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">aria-controls</span>=<span class="string">&quot;navbarNav&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">aria-label</span>=<span class="string">&quot;Toggle navigation&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggler-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;collapse navbar-collapse justify-content-between&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;navbarNav&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;navbar-nav&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link &#123;&#123;&#x27;active&#x27; if active==&#x27;index&#x27;&#125;&#125;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span>Home <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bi bi-house-fill&quot;</span>&gt;</span>&lt;/i</span><br><span class="line">          &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;nav-link &#123;&#123;&#x27;active&#x27; if active==&#x27;customer&#x27;&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">href</span>=<span class="string">&quot;/customer&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span>Customers <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bi bi-person-fill&quot;</span>&gt;</span>&lt;/i</span><br><span class="line">          &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-end&quot;</span>&gt;</span></span><br><span class="line">        &#123;% if current_user and current_user.nickname %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/customer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span>&#123;&#123; current_user.nickname &#125;&#125; <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bi bi-person-square&quot;</span>&gt;</span>&lt;/i</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/user/logout&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-primary&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span>Logout <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bi bi-box-arrow-left&quot;</span>&gt;</span>&lt;/i</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">&quot;/user/login&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;btn &#123;&#123; &#x27;btn-primary&#x27; if active==&#x27;login&#x27; else &#x27;btn-outline-primary&#x27; &#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span>Login <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bi bi-box-arrow-in-right&quot;</span>&gt;</span>&lt;/i</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">&quot;/user/register&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;btn &#123;&#123; &#x27;btn-outline-primary&#x27; if active==&#x27;login&#x27; else &#x27;btn-primary&#x27; &#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span>Sign up <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;bio bi-people-fill&quot;</span>&gt;</span>&lt;/i</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125; &#123;% block main %&#125; &#123;% endblock %&#125;&#123;% block aside %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;aside container&quot;</span>&gt;</span></span><br><span class="line">  &#123;% with messages=get_flashed_messages() %&#125; &#123;% for message in messages %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if message %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;alert alert-warning fs-6 text-break&quot;</span> <span class="attr">role</span>=<span class="string">&quot;alert&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125; &#123;% endwith %&#125; &#123;% if form and form.errors %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% for _,v in form.errors.items() %&#125; &#123;% for msg in v %&#125; &#123;% if msg %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;alert alert-warning fs-6 text-break&quot;</span> <span class="attr">role</span>=<span class="string">&quot;alert&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125; &#123;% block footer %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;footer w-100 py-3 text-center text-secondary fs-6&quot;</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;copy;</span>Christopher-Teng</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;样式上面直接使用了 Bootstrap，相关静态文件放置与 app/static 下面：</p>
<img src="/2021/07/21/%E4%BD%BF%E7%94%A8Flask%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/static_dir.jpeg" class="" title="static files">
<p>&emsp;&emsp;其中，侧边栏中<code>&#123;% with messages=get_flashed_messages() %&#125;</code>使用了 Flask 提供的闪现(flash)在页面中嵌入视图函数中传入的自定义信息，<code>&#123;% if form and form.errors %&#125;</code>则是表单信息通过 wtforms 验证失败后的错误信息，通过在视图函数中使用<code>render_template</code>渲染模板时，传入 form 表单验证对象取得。</p>
<p>&emsp;&emsp;下面编写用户注册页面：</p>
<figure class="highlight html"><figcaption><span>app/templates/register.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125; &#123;% set active=&quot;register&quot; %&#125; &#123;% block main %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;main row my-3 text-secondary&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-6 mx-auto px-3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;nicknameInput&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;your nickname&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;nickname&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">required</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;form.data.get(&#x27;nickname&#x27;)|default(&#x27;&#x27;,True)&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nicknameInput&quot;</span>&gt;</span>Nickname<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;email&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;emailInput&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;your email&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;email&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">required</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;form.data.get(&#x27;email&#x27;)|default(&#x27;&#x27;,True)&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;emailInput&quot;</span>&gt;</span>Email address<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;phoneNumberInput&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;your phone number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;phone_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">required</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;form.data.get(&#x27;phone_number&#x27;)|default(&#x27;&#x27;,True)&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;phoneNumberInput&quot;</span>&gt;</span>Phone number<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;passwordInput&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">required</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;passwordInput&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;csrf_token()&#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;w-100 btn btn-primary btn-lg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Sign up<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面注册表单中，<code>&lt;input type=&quot;hidden&quot; name=&quot;csrf_token&quot; value=&quot;&#123;&#123;csrf_token()&#125;&#125;&quot; /&gt;</code>使用了表单隐藏字段，用于防御 CSRF(跨站请求伪造，Cross-site request forgery)，这是 flask-wtf 插件提供的功能，需要使用 flask-wtf 的 CsrfProtect 类的实例来初始化应用：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> CsrfProtect</span><br><span class="line"></span><br><span class="line"><span class="comment"># def create_app():</span></span><br><span class="line">  <span class="comment"># app=Flask(__name__)</span></span><br><span class="line">  csrf=CsrfProtect()</span><br><span class="line">  csrf.init_app(app)</span><br><span class="line">  <span class="comment"># pass</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;到此，用户注册功能已经实现，下面实现用户登录功能。</p>
<h2 id="用户登录接口与页面"><a href="#用户登录接口与页面" class="headerlink" title="用户登录接口与页面"></a>用户登录接口与页面</h2><p>&emsp;&emsp;用户登录的代码和用户注册非常相似，主要区别是在表单数据上，登录页面可以使用注册过的邮箱或者手机号来进行用户验证，因此在视图函数中应该对表单数据做邮箱和手机号两方面验证，具体代码如下：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="meta">  @auth.route(<span class="params"><span class="string">&quot;/login&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST])</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="meta">  def login():</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="meta">    form=LoginForm()</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="meta">    if form.validate_on_submit():</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="meta">      email_or_phone_number=request.form.get(&quot;</span>email_or_phone_numbe<span class="string">r&quot;)</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="meta">      password=request.form.get(&quot;</span>password</span>)</span></span><br><span class="line">      user=_login(email_or_phone_number)</span><br><span class="line">      <span class="keyword">if</span> user <span class="keyword">and</span> user.check_password(password):</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;web.index&quot;</span>))</span><br><span class="line">      flash(<span class="string">u&quot;用户不存在或密码错误！&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;login.html&quot;</span>,form=form)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_login</span>(<span class="params">email_or_phone_number</span>):</span></span><br><span class="line">    user=User.query.filter_by(email=email_or_phone_number).first() <span class="keyword">or</span> User.query.filter_by(</span><br><span class="line">      phone_number=email_or_phone_number).first()</span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编写登录页表单验证：</p>
<figure class="highlight python"><figcaption><span>app/forms/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    email_or_phone_number = StringField(validators=[DataRequired()])</span><br><span class="line">    password = PasswordField(validators=[DataRequired(),</span><br><span class="line">                                         Length(<span class="built_in">min</span>=<span class="number">6</span>, <span class="built_in">max</span>=<span class="number">32</span>),</span><br><span class="line">                                         Regexp(<span class="string">r&quot;^\w&#123;6,32&#125;$&quot;</span>, flags=<span class="number">0</span>, message=<span class="string">u&quot;密码最少6位最多32位字符，并且不能使用特殊字符&quot;</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_email_or_phone_number</span>(<span class="params">self, field</span>):</span></span><br><span class="line">        res = re.search(</span><br><span class="line">            <span class="string">r&quot;^((\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)|((13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d&#123;8&#125;))$&quot;</span>,</span><br><span class="line">            field.data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&quot;please input email or phone number!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以及登录页面：</p>
<figure class="highlight html"><figcaption><span>app/templates/login.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125; &#123;% set active=&quot;login&quot; %&#125; &#123;% block main %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;main row my-3 text-secondary&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">    <span class="attr">action</span>=<span class="string">&quot;&#123;&#123;url_for(&#x27;auth.login&#x27;,next=request.args.get(&#x27;next&#x27;))&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;col-sm-6 mx-auto px-3&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;emailOrPhoneNumberInput&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;email or phone number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;email_or_phone_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">required</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;emailOrPhoneNumberInput&quot;</span>&gt;</span>Email / Phone number<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;passwordInput&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">required</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;passwordInput&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check mb-2 py-2 d-flex justify-content-center&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;rememberMeCheck&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;remember_me&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">&quot;remember_me&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;rememberMeCheck&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label ms-2&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span>Remember me&lt;/label</span><br><span class="line">      &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;csrf_token()&#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;w-100 btn btn-primary btn-lg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户登录状态保持"><a href="#用户登录状态保持" class="headerlink" title="用户登录状态保持"></a>用户登录状态保持</h2><p>&emsp;&emsp;当用户登录以后，往往需要保持用户登录状态，一方面提高用户体验，不需要每次打开页面都要求重新登录，另一方面，在多个页面之间共享登录状态，实现访问控制和一些特殊的业务逻辑。</p>
<p>&emsp;&emsp;下面将使用 Flask 的第三方插件 flask-login 来实现登录状态保持，首先实例化一个 flask-login 插件的 LoginManager 类，然后初始化应用：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> LoginManager</span><br><span class="line"></span><br><span class="line">login_manager=LoginManager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># def create_app():</span></span><br><span class="line">  <span class="comment"># app=Flask(__name__)</span></span><br><span class="line">  login_manager.init_app(app)</span><br><span class="line">  <span class="comment"># pass</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;flask-login 提供了很多可配置项，下面首先配置 login_view——未登录时自动跳转的 endpoint 和提示信息：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line">  <span class="comment"># login_manager.init_app(app)</span></span><br><span class="line">  login_manager.login_view=<span class="string">&quot;auth.login&quot;</span></span><br><span class="line">  login_manager.login_message=<span class="string">&quot;Please login first&quot;</span></span><br><span class="line">  <span class="comment"># pass</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;改写用户信息表的代码，加入 flask-login，具体用法可以网上查找文档自行了解：</p>
<figure class="highlight python"><figcaption><span>app/models/user.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base, UserMixin</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    nickname = Column(String(<span class="number">20</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    email = Column(String(<span class="number">50</span>), nullable=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    phone_number = Column(<span class="string">&quot;phone_number&quot;</span>, String(<span class="number">11</span>), nullable=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    _password = Column(<span class="string">&quot;password&quot;</span>, String(<span class="number">128</span>), nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._password</span><br><span class="line"></span><br><span class="line"><span class="meta">    @password.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span>(<span class="params">self, raw</span>):</span></span><br><span class="line">        self._password = generate_password_hash(raw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_password</span>(<span class="params">self, raw</span>):</span></span><br><span class="line">        <span class="keyword">return</span> check_password_hash(self.password, raw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_manager.user_loader</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_user</span>(<span class="params">uid</span>):</span></span><br><span class="line">    <span class="keyword">return</span> User.query.filter_by(<span class="built_in">id</span>=uid).first()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;UserMixin 是 flask-login 提供的方便开发者进行扩展的基类，主要提供了一些使用 flask-login 所必须要实现的类方法。</p>
<p>&emsp;&emsp;flask-login 默认只在会话期间记录用户登录状态，但是可以通过指定 remember 的相关配置，在指定时间内保持登录状态。</p>
<p>&emsp;&emsp;首先在配置文件中对 flask-login 进行配置：</p>
<figure class="highlight python"><figcaption><span>app/__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line">SECRET_KEY = <span class="string">&quot;!@#$%^&amp;*&quot;</span></span><br><span class="line">SQLALCHEMY_DATABASE_URI = <span class="string">&quot;mysql+pymysql://root:123456@localhost:3306/flask&quot;</span></span><br><span class="line">SQLALCHEMY_ECHO = <span class="literal">True</span></span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATION = <span class="literal">True</span></span><br><span class="line">REMEMBER_COOKIE_DURATION = timedelta(days=<span class="number">7</span>)</span><br><span class="line">REMEMBER_COOKIE_HTTPONLY = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里配置为保存用户登录信息 7 天。接下来在用户登录视图函数中记录登录状态：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="comment"># def login():</span></span><br><span class="line"><span class="comment">#   pass</span></span><br><span class="line"><span class="comment">#   if user and user.check_password(password):</span></span><br><span class="line">      login_user(user, remember=remember_me)</span><br><span class="line">            <span class="built_in">next</span> = request.args.get(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;next: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">next</span>))</span><br><span class="line">            <span class="built_in">next</span> = <span class="built_in">next</span> <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">and</span> <span class="built_in">next</span>.startswith(<span class="string">&quot;/&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="built_in">next</span>)</span><br><span class="line"><span class="comment">#   pass</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中，next 是当我们访问要求登录验证的页面时，flask-login 会将请求重定向到我们设置的<code>login_view</code>，而跳转前的 path 则会被已查询参数的方式记录下来，及 next 的值，因此当用户成功登录后，可以通过 next 参数将页面重定向到用户之前试图访问的页面，这里要注意对 next 进行必要的验证，防止通过访问登陆页面时指定恶意的 next 查询参数进行攻击。</p>
<p>&emsp;&emsp;最后，加上用户登出逻辑，并且添加一个用户页面进行访问控制：</p>
<figure class="highlight python"><figcaption><span>app/manager/auth.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="meta">@auth.route(<span class="params"><span class="string">&quot;/logout&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>():</span></span><br><span class="line">    logout_user()</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;web.index&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>app/manager/web.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上文</span></span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> login_required</span><br><span class="line"></span><br><span class="line"><span class="meta">@web.route(<span class="params"><span class="string">&quot;/customer&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer</span>():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;customer.html&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>app/templates/customer.html</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125; &#123;% set active=&quot;customer&quot; %&#125; &#123;% block main %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;h1 text-center&quot;</span>&gt;</span></span><br><span class="line">    Welcome back,&#123;&#123;current_user.nickname | default(&quot;&quot;,true)&#125;&#125;!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在本篇中，通过实现一个非常简单经典的用户注册、登录功能，熟悉了 flask 的基础开发流程，了解了 flask 中的消息闪现、jinja 模板以及 blueprint 蓝图，另外还涉及到了一些常用的 flask 第三方插件，主要有 flask-sqlalchemy 使用 ORM 数据模型进行数据库操作、flask-wtf 进行表单校验以及 flask-login 进行登录状态保持，并且通过自定义函数装饰器和上下文管理器对数据库操作进行了优化，实践了这两种 python 中的高级语法。文中项目完整代码参见<a href="https://github.com/Christopher-Teng/flask_signup-login-logout">此处</a>。</p>
]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Scrapy爬取诗词数据（终）</title>
    <url>/2021/05/04/%E4%BD%BF%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E8%AF%97%E8%AF%8D%E6%95%B0%E6%8D%AE%EF%BC%88%E7%BB%88%EF%BC%89/</url>
    <content><![CDATA[<p>前文中，我们已经成功从诗词详情页爬取到了数据，接下来对数据内容根据需求进行加工处理以及存储。</p>
<p>首先，对标题进行处理，将其改为原标题加上正文第一句的形式。对数据的处理可以通过自定义管道来实现，scrapy 的管道可以将数据一层一层的进行复杂逻辑的处理，每一个管道类都需要返回 item，已保证数据可以在多个管道类之间流动。</p>
<p>使用 scrapy 创建爬虫项目时，会在项目目录下自动创建一个<code>pipelines.py</code>文件，其中已经预定义了一个和项目同名的管道类，我们就从这里开始编写数据处理逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">from</span> scrapy.exception <span class="keyword">import</span> DropItem</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .processors <span class="keyword">import</span> modify_title</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhscCrawlerPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.logger=logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        adapter = ItemAdapter(item)</span><br><span class="line">        <span class="keyword">if</span> adapter[<span class="string">&#x27;title&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> adapter[<span class="string">&#x27;content&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem()</span><br><span class="line">        adapter[<span class="string">&#x27;title&#x27;</span>] = modify_title(adapter[<span class="string">&#x27;title&#x27;</span>], adapter[<span class="string">&#x27;content&#x27;</span>])</span><br><span class="line">        self.logger.debug(<span class="string">u&#x27;标题已成功经过修改，格式为：原标题 —— 诗文内容第一行 -- %(title)s&#x27;</span>, &#123;<span class="string">&#x27;title&#x27;</span>: adapter[<span class="string">&#x27;title&#x27;</span>]&#125;)</span><br><span class="line">        spider.crawler.stats.inc_value(<span class="string">&#x27;title_modify/modified&#x27;</span>, spider=spider)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这里引入了<code>ItemAdapter</code>，这是 scrapy 提供的用于处理 item 的类，可以通过字段名获取 item 中的数据。</p>
<p>首先提取<code>title</code>字段和<code>content</code>字段的值，并且如果标题为空或者正文为空时，抛出一个<code>DropItem</code>，这是 scrapy 提供的用于丢弃数据的类，此处诗词数据如果没有标题或正文，则将该条数据抛弃。</p>
<p>然后调用在<code>processors.py</code>中自定义的标题处理方法<code>modify_title</code>，将处理后的返回值赋值给<code>title</code>字段以覆盖原标题，最后使用 python 的标准库<code>logging</code>打印日志，方便调试。</p>
<p><code>spider.crawler.stats.inc_value</code>是 scrapy 内置的状态记录方法，同样用于调试时查看爬虫运行情况。</p>
<p>下面是<code>modify_title</code>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_title</span>(<span class="params">title, content</span>):</span></span><br><span class="line">    first_line = re.match(<span class="string">r&#x27;(.+)(?=\n)&#x27;</span>, content).group()</span><br><span class="line">    title = title+<span class="string">&#x27; —— &#x27;</span>+first_line</span><br><span class="line">    <span class="keyword">return</span> title</span><br></pre></td></tr></table></figure>
<p>处理逻辑很简单，使用正则提取正文第一句，由于在 item 中定义<code>content</code>字段时，使用了<code>parse_content</code>方法把正文的每一个完整诗句进行换行，所以我们只需要匹配第一个换行符前面的内容就可以得到正文第一句。处理后返回的结果为：“原标题 —— 正文第一句”。</p>
<p>到此，可以运行爬虫爬取符合需求的诗词数据了，接下来对数据进行存储。最简单的存储方式就是在<code>settings.py</code>爬虫配置文件中，配置<code>FEEDS</code>字段，scrapy 默认支持的存储方式主要有：Local filesystem、FTP、S3、Google Cloud Storage 和 Standard output，这里我们配置为使用 JSON Lines 格式将数据存储到项目根目录下的<code>poems</code>目录下，文件名为<code>poems.jsonl</code>，该格式类似 JSON，使用逐行的方式存储数据，每行都是一个标准的 JSON 字符串，其优点一是方便追加数据，二是每一行都是一个标准的 JSON 格式字符串，所以使用的时候可以按行读取数据，避免文件过大，一次全部读取造成性能瓶颈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FEEDS=&#123;</span><br><span class="line">    pathlib.Path(<span class="string">&#x27;poems/poems.jsonl&#x27;</span>):&#123;</span><br><span class="line">        <span class="string">&#x27;format&#x27;</span>:<span class="string">&#x27;jsonlines&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;encoding&#x27;</span>:<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于直接存储与本地文件，更好的方式是使用数据库进行存储，下面在<code>pipelines.py</code>中编写一个<code>MongoDBPipeline</code>来通过自定义管道将数据存储进 MongoDB 中，在 python 中使用 mongodb 推荐使用 pymongo。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoDBPipeline</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">27017</span>,username=<span class="string">&#x27;&#x27;</span>,password=<span class="string">&#x27;&#x27;</span>,auth_source=<span class="string">&#x27;&#x27;</span>, db_name=<span class="string">&#x27;zhsc_crawler&#x27;</span>, col_name=<span class="string">&#x27;poems&#x27;</span></span>):</span></span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line">        self.username=username</span><br><span class="line">        self.password=password</span><br><span class="line">        self.auth_source=auth_source</span><br><span class="line">        self.db_name=db_name</span><br><span class="line">        self.col_name=col_name</span><br><span class="line">        self.logger=logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls,crawler</span>):</span></span><br><span class="line">        _host = crawler.settings.get(<span class="string">&#x27;MONGO_HOST&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line">        _port = crawler.settings.getint(<span class="string">&#x27;MONGO_PORT&#x27;</span>, <span class="number">27017</span>)</span><br><span class="line">        _username=crawler.settings.get(<span class="string">&#x27;MONGO_USERNAME&#x27;</span>,<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">        _password=crawler.settings.get(<span class="string">&#x27;MONGO_PASSWORD&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">        _auth_source=crawler.settings.get(<span class="string">&#x27;MONGO_AUTHSOURCE&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">        _db_name = crawler.settings.get(<span class="string">&#x27;MONGO_DB&#x27;</span>, <span class="string">&#x27;zhsc_crawler&#x27;</span>)</span><br><span class="line">        _col_name = crawler.settings.get(<span class="string">&#x27;MONGO_COLLECTION&#x27;</span>, <span class="string">&#x27;poems&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(_host, _port,_username,_password,_auth_source, _db_name, _col_name)</span><br></pre></td></tr></table></figure>
<p>上面代码首先读取 mongodb 配置，准备好进行数据库连接，其中类方法<code>from_crawler</code>是 scrapy 提供的管道类中读取爬虫配置文件的方法。</p>
<p>在<code>settings.py</code>中配置 mongodb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MONGO_HOST = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">MONGO_PORT = <span class="number">27017</span></span><br><span class="line">MONGO_USERNAME = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">MONGO_PASSWORD = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">MONGO_AUTHSOURCE = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">MONGO_DB = <span class="string">&quot;zhsc_crawler&quot;</span></span><br><span class="line">MONGO_COLLECTION = <span class="string">&quot;poems&quot;</span></span><br></pre></td></tr></table></figure>
<p>MongoDB 的相关知识这里不单独做解释，网上资料很多，而且 MongoDB 上手也很简单。这里配置使用的数据库名称为<code>zhsc_crawler</code>，集合名称<code>poems</code>。</p>
<p>对数据库的连接和关闭可以放在运行爬虫和爬虫运行完毕时，这样可以有效节省开销：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">    self.connection = pymongo.MongoClient(host=self.host, port=self.port,username=self.username,password=self.password,authSource=self.auth_source)</span><br><span class="line">    self.db = self.connection[self.db_name]</span><br><span class="line">    self.collection = self.db[self.col_name]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">    self.connection.close()</span><br></pre></td></tr></table></figure>
<p><code>open_spider</code>和<code>close_spider</code>由 scrapy 提供，用于在蜘蛛启动和关闭时自定义操作。</p>
<p>最后是管道类必须实现的方法<code>process_item</code>，用于处理数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">    adapter = ItemAdapter(item)</span><br><span class="line">    self.collection.insert_one(<span class="built_in">dict</span>(item))</span><br><span class="line">    self.logger.debug(<span class="string">u&#x27;数据已插入MongoDB！ %(title)s -- %(times)s -- %(author)s&#x27;</span>,&#123;<span class="string">&#x27;title&#x27;</span>: adapter[<span class="string">&#x27;title&#x27;</span>], <span class="string">&#x27;times&#x27;</span>: adapter[<span class="string">&#x27;times&#x27;</span>], <span class="string">&#x27;author&#x27;</span>: adapter[<span class="string">&#x27;author&#x27;</span>]&#125;)</span><br><span class="line">    spider.crawler.stats.inc_value(<span class="string">&#x27;mongodb/inserted&#x27;</span>, spider=spider)</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>最后，在<code>settings.py</code>中配置<code>ITEM_PIPELINES</code>字段，开启自定义管道，默认只开启了创建项目时 scrapy 自动创建的项目同名管道类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES=&#123;</span><br><span class="line">    <span class="string">&#x27;zhsc_crawler.pipelines.ZhscCrawlerPipeline&#x27;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">&#x27;zhsc_crawler.pipelines.MongoDBPipeline&#x27;</span>:<span class="number">500</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的数值表示优先级，数值越小优先级越高，数据会依从优先级顺序在管道中传递进行处理。</p>
<p>到这里，爬虫开发已经接近完成，下面来考虑一些优化设置。</p>
<p>首先，一些大型网站，或者迭代周期很长的网站，他们的页面中可能存在着一些循环引用的链接，可能是无意造成的，也可能是故意设置，使爬虫陷入死循环，已进行反爬。因此我们因该在爬取时对重复的请求链接进行过滤。scrapy 默认开启了 RFPDupeFilter，通过生成一个 request_seen 文件记录请求指纹，然后在每次发出请求前先检查当前请求是否已经记录过，从而达到过滤重复请求的目的。</p>
<p>然后，当我们爬取的数据量非常大时，request_seen 文件体积将会不断增大，而运行爬虫时需要将该文件读入内存，这可能造成内存占用过大，最终导致程序崩溃。</p>
<p>一种办法是改成使用 Redis 来存储请求指纹，借助 Redis 的高性能，不需要一次性读取全部记录，从而改善默认 RFPDupeFilter 的缺陷，但是数据量太大时，使用 Redis 存储请求指纹仍然会占用大量内存。</p>
<p>这里采用另一种方式，Redis 结合布隆过滤器进行过滤。布隆过滤器的详细原理可以自行上网了解，布隆过滤器的优点是占用空间很少，缺点则是有一定的误判率，使用 Redis 内置的 bitset 可以方便的实现布隆过滤器，下面直接给出代码以及简单解释，在项目目录下新建<code>dupefilter.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> scrapy.dupefilters <span class="keyword">import</span> BaseDupeFilter</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.request <span class="keyword">import</span> request_fingerprint</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .hashmap <span class="keyword">import</span> HashMap</span><br></pre></td></tr></table></figure>
<p>这里引入 scrapy 提供的 <code>BaseDupeFilter</code> 作为自定义 dupefilter 的基类，以及 <code>request_fingerprint</code> 方法生成请求指纹。</p>
<p>引入 python 标准库 <code>hashlib</code> 用于后面使用 md5 和 logging 生成日志。</p>
<p>自定义类<code>HashMap</code>用于生成布隆过滤器使用的哈希函数。</p>
<p>引入 redis 来连接操作 Redis。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,m,seed</span>):</span></span><br><span class="line">        self.m=m</span><br><span class="line">        self.seed=seed</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        ret=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)):</span><br><span class="line">            ret+=self.seed*ret+<span class="built_in">ord</span>(value[i])</span><br><span class="line">        <span class="keyword">return</span> (self.m-<span class="number">1</span>)&amp;ret</span><br></pre></td></tr></table></figure>
<p>上面代码中，m 为布隆过滤器需要使用的位大小，seed 用于生成多个 hash 函数，hash 方法则把输入字符串映射到多个位，并且将对应位设置为 1。</p>
<p>下面编写基于 Redis 的布隆过滤器的主体代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisBloomDupeFilter</span>(<span class="params">BaseDupeFilter</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, bitSize=<span class="number">32</span>, seeds=[<span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>], blockNum=<span class="number">1</span>, key=<span class="string">&#x27;bloomfilter&#x27;</span></span>):</span></span><br><span class="line">        self.redis = Redis(host=host, port=port, db=db)  <span class="comment"># 连接Redis</span></span><br><span class="line">        self.bitSize = <span class="number">1</span> &lt;&lt; bitSize  <span class="comment"># 在Redis中申请一个BitSet，Redis中BitSet实际上使用String进行存储，因此最大容量为512M，即2^32</span></span><br><span class="line">        self.seeds = seeds  <span class="comment"># 生成多个hash函数的种子</span></span><br><span class="line">        self.key = key  <span class="comment"># Redis中使用的键名</span></span><br><span class="line">        self.blockNum = blockNum  <span class="comment"># Redis中总共申请多少个BitSet</span></span><br><span class="line">        self.hashFunc = []  <span class="comment"># hash函数</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> self.seeds:</span><br><span class="line">            <span class="comment"># 根据提供的种子生成多个hash函数</span></span><br><span class="line">            self.hashFunc.append(HashMap(self.bitSize, seed))</span><br><span class="line">            self.logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_settings</span>(<span class="params">cls,settings</span>):</span></span><br><span class="line">        <span class="comment"># scrapy提供的dupefilter中读取爬虫配置的方法</span></span><br><span class="line">        _host = settings.get(<span class="string">&#x27;REDIS_HOST&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">        _port = settings.getint(<span class="string">&#x27;REDIS_PORT&#x27;</span>, <span class="number">6379</span>)</span><br><span class="line">        _db = settings.getint(<span class="string">&#x27;REDIS_DUPE_DB&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">        _bitSize = settings.getint(<span class="string">&#x27;BLOOMFILTER_BIT_SIZE&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">        _seeds = settings.getlist(<span class="string">&#x27;BLOOMFILTER_HASH_SEEDS&#x27;</span>, [])</span><br><span class="line">        _blockNum = settings.getint(<span class="string">&#x27;BLOOMFILTER_BLOCK_NUMBER&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        _key = settings.get(<span class="string">&#x27;BLOOMFILTER_REDIS_KEY&#x27;</span>, <span class="string">&#x27;bloomfilter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(_host, _port, _db, _bitSize, _seeds, _blockNum, _key)</span><br></pre></td></tr></table></figure>
<p>在<code>settings.py</code>中加入 Redis 和布隆过滤器相应配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REDIS_HOST = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">REDIS_PORT = <span class="number">6379</span></span><br><span class="line">REDIS_DUPE_DB = <span class="number">0</span></span><br><span class="line">BLOOMFILTER_REDIS_KEY = <span class="string">&quot;bloomfilter&quot;</span></span><br><span class="line">BLOOMFILTER_BLOCK_NUMBER = <span class="number">1</span></span><br><span class="line">BLOOMFILTER_BIT_SIZE = <span class="number">31</span></span><br><span class="line">BLOOMFILTER_HASH_SEEDS = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">31</span>, <span class="number">37</span>]</span><br></pre></td></tr></table></figure>
<p>接着完成<code>dupefilter.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span>(<span class="params">self, request</span>):</span></span><br><span class="line">    fp = request_fingerprint(request)</span><br><span class="line">    <span class="keyword">if</span> self.exists(fp):</span><br><span class="line">        <span class="comment"># 如果请求指纹已经存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    self.insert(fp)  <span class="comment"># 如果请求指纹不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, str_input</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加入请求指纹</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    md5.update(<span class="built_in">str</span>(str_input).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    _<span class="built_in">input</span> = md5.hexdigest()</span><br><span class="line">    _name = self.key+<span class="built_in">str</span>(<span class="built_in">int</span>(_<span class="built_in">input</span>[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>) % self.blockNum)</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> self.hashFunc:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将hash映射后的bit为置位为1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        _offset = func.<span class="built_in">hash</span>(_<span class="built_in">input</span>)</span><br><span class="line">        self.redis.setbit(_name, _offset, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span>(<span class="params">self, str_input</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">判断请求指纹是否已存在</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> str_input:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="built_in">str</span>(str_input).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">_<span class="built_in">input</span> = md5.hexdigest()</span><br><span class="line">_name = self.key+<span class="built_in">str</span>(<span class="built_in">int</span>(_<span class="built_in">input</span>[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>) % self.blockNum)</span><br><span class="line">ret = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> self.hashFunc:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    如果经过hash映射之后对应的bit位上有任意一个0，则一定不存在</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _offset = func.<span class="built_in">hash</span>(_<span class="built_in">input</span>)</span><br><span class="line">    ret = ret &amp; self.redis.getbit(_name, _offset)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">self.logger.debug(<span class="string">u&#x27;已过滤的重复请求：%(request)s&#x27;</span>, &#123;<span class="string">&#x27;request&#x27;</span>: request&#125;)</span><br><span class="line">spider.crawler.stats.inc_value(<span class="string">&#x27;redisbloomfilter/filtered&#x27;</span>, spider=spider)</span><br></pre></td></tr></table></figure>
<p>最后，在<code>settings.py</code>中开启自定义 dupefilter：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DUPEFILTER_CLASS = <span class="string">&#x27;zhsc_crawler.dupefilter.RedisBloomDupeFilter&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后，在做一些反爬优化，首先可以通过为每个请求添加随机 User-Agent 来伪装不同客户端，要实现这一点可以通过scrapy的<code>Downloader Middleware</code>，下载器中间件位于downloader和scrapy engine之间，当engine通知downloader开始从指定url下载数据前，可以在下载器中间件中定义一些预操作。例如，先在<code>settings.py</code>中添加一组 UA，可以从网上找到很多 UA 信息，然后自定义一个<code>ZhscRandomUserAgentMiddleware</code>中间件类，每当downloader开始下载数据前，都对请求头设置一个随机UA：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhscRandomUserAgentMiddleware</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, user_agents=[]</span>):</span></span><br><span class="line">        self.user_agents = user_agents</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(crawler.settings.getlist(<span class="string">&#x27;UA_Pool&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.user_agents <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.user_agents) &gt; <span class="number">0</span>:</span><br><span class="line">            request.headers.setdefault(<span class="string">b&#x27;User-Agent&#x27;</span>, random.choice(self.user_agents))</span><br></pre></td></tr></table></figure>
<p>其中，<code>from_crawler</code>是 scrapy 提供的读取配置文件的类方法，而<code>process_request</code>则是中间件类必须实现的请求处理方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UA_Pool = [</span><br><span class="line">    <span class="comment"># User-Agent</span></span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/5.0 (Windows NT 10.0;Win64;x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Edg/89.0.774.76&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv,2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/5.0 (Windows NT 6.1; rv,2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent, Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent,Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 UBrowser/6.2.4094.1 Safari/537.36&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>然后在<code>settings.py</code>中配置使用自定义中间件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable or disable downloader middlewares</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html</span></span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="comment">#    &#x27;zhsc_crawler.middlewares.ZhscCrawlerDownloaderMiddleware&#x27;: 543,</span></span><br><span class="line">    <span class="comment"># 发出请求前添加随机UA</span></span><br><span class="line">    <span class="string">&#x27;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">&#x27;zhsc_crawler.middlewares.ZhscRandomUserAgentMiddleware&#x27;</span>: <span class="number">800</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意要先关闭 scrapy 默认的 UA 中间件。</p>
<p>最后，如果爬虫频繁发出大量请求的话，很容易被做了反爬的网站发现，因此可以通过在<code>settings.py</code>中对爬虫进行限速来预防，scrapy 提供了很方便的实现方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable and configure the AutoThrottle extension (disabled by default)</span></span><br><span class="line"><span class="comment"># See https://docs.scrapy.org/en/latest/topics/autothrottle.html</span></span><br><span class="line">AUTOTHROTTLE_ENABLED = <span class="literal">True</span></span><br><span class="line"><span class="comment"># The initial download delay</span></span><br><span class="line">AUTOTHROTTLE_START_DELAY = <span class="number">5</span></span><br><span class="line"><span class="comment"># The maximum download delay to be set in case of high latencies</span></span><br><span class="line">AUTOTHROTTLE_MAX_DELAY = <span class="number">60</span></span><br><span class="line"><span class="comment"># The average number of requests Scrapy should be sending in parallel to</span></span><br><span class="line"><span class="comment"># each remote server</span></span><br><span class="line">AUTOTHROTTLE_TARGET_CONCURRENCY = <span class="number">1.0</span></span><br><span class="line"><span class="comment"># Enable showing throttling stats for every response received:</span></span><br><span class="line">AUTOTHROTTLE_DEBUG = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>到此，整个诗词数据爬虫开发便完成了，完整代码放在我的<a href="https://github.com/Christopher-Teng/poems_crawler.git">github 仓库</a>。</p>
]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
</search>
